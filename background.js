let cpp = [
	
	{
		id: 1,
		title: "Q1. What is the output of this code?",
		text: undefined,
		code2: 'fun main() { val list = listOf(1, 2, 3, 4, 5) println(list.subList(1, 3)) }',
		choices: ["1. [1, 2, 3]", "2. [1, 2]", "3. [2, 3]", "4. [2, 3, 4]"],
		answer: "3. [2, 3]",
	},
	{
		id: 2,
		title: "Q2. What is the output of this code?",
		text: undefined,
		code2: 'fun main() { val x = 10 val y = 20 println(x.rangeTo(y)) }',
		choices: ["1. 10..20", "2. 10..19", "3. 11..20", "4. 11..19"],
		answer: "1. 10..20",
	},
	{
		id: 3,
		title: "Q3. What is the output of this code?",
		text: undefined,
		code2: 'fun main() { val list = listOf(1, 2, 3, 4, 5) println(list.filter { it % 2 == 0 }) }',
		choices: ["1. [1, 2, 3, 4, 5]", "2. [2, 4]", "3. [1, 3, 5]", "4. [2, 3, 4]"],
		answer: "2. [2, 4]",
	},
	{
		id: 4,
		title: "Q4. What is the output of this code?",
		text: undefined,
		code2: 'fun main() { val x = 10 val y = 20 println(x..y step 2) }',
		choices: ["1. 10, 12, 14, 16, 18, 20", "2. 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20", "3. 10, 12, 14, 16, 18", "4. 10, 11, 12, 13, 14, 15, 16, 17, 18, 19"],
		answer: "1. 10, 12, 14, 16, 18, 20",
	},
	{
		id: 5,
		title: "Q5. What is the output of this code?",
		text: undefined,
		code2: 'fun main() { val list = listOf(1, 2, 3, 4, 5) println(list.map { it * 2 }) }',
		choices: ["1. [1, 2, 3, 4, 5]", "2. [2, 4, 6, 8, 10]", "3. [1, 3, 5]", "4. [2, 3, 4]"],
		answer: "2. [2, 4, 6, 8, 10]",
	},
	{
		id: 6,
		title: "Q6. What is the output of this code?",
		text: undefined,
		code2: 'fun main() { val list = listOf(1, 2, 3, 4, 5) println(list.reduce { acc, next -> acc + next }) }',
		choices: ["1. 15", "2. 10", "3. 5", "4. 0"],
		answer: "1. 15",
	},
	{
		id: 7,
		title: "Q7. What is the output of this code?",
		text: undefined,
		code2: 'fun main() { val list = listOf(1, 2, 3, 4, 5) println(list.fold(0) { acc, next -> acc + next }) }',
		choices: ["1. 15", "2. 10", "3. 5", "4. 0"],
		answer: "1. 15",
	},
	{
		id: 8,
		title: "Q8. What is the output of this code?",
		text: undefined,
		code2: 'fun main() { val x = 10 val y = 20 println(x until y) }',
		choices: ["1. 10..20", "2. 10..19", "3. 11..20", "4. 11..19"],
		answer: "2. 10..19",
	},
	{
		id: 9,
		title: "Q9. What is the output of this code?",
		text: undefined,
		code2: 'fun main() { val list = listOf(1, 2, 3, 4, 5) println(list.any { it % 2 == 0 }) }',
		choices: ["1. true", "2. false", "3. null", "4. 0"],
		answer: "1. true",
	},
	{
		id: 10,
		title: "Q10. What is the output of this code?",
		text: undefined,
		code2: 'fun main() { val list = listOf(1, 2, 3, 4, 5) println(list.all { it % 2 == 0 }) }',
		choices: ["1. true", "2. false", "3. null", "4. 0"],
		answer: "2. false",
	},
	{
		id: 11,
		title: "Q11. Which of the following is a valid way to declare a nullable string in Kotlin?",
		text: undefined,
		code2: "  ",
		choices: ["1. String? name", "2. String name?", "3. nullable String name", "4. String name = null"],
		answer: "1. String? name",
	},
	{
		id: 12,
		title: "Q12. What is the purpose of the !! operator in Kotlin?",
		text: undefined,
		code2: "  ",
		choices: [
			"1. It checks if a value is null and throws an exception if it is.",
			"2. It checks if a value is not null and throws an exception if it is not.",
			"3. It converts a nullable value to a non-nullable value.",
			"4. It is used to declare a nullable variable.",
		],
		answer: "1. It checks if a value is null and throws an exception if it is.",
	},
	{
		id: 13,
		title: "Q13. What is the purpose of the ? operator in Kotlin?",
		text: undefined,
		code2: "  ",
		choices: [
			"1. It checks if a value is null and throws an exception if it is.",
			"2. It checks if a value is not null and throws an exception if it is not.",
			"3. It converts a nullable value to a non-nullable value.",
			"4. It is used to declare a nullable variable.",
		],
		answer: "3. It converts a nullable value to a non-nullable value.",
	},
	{
		id: 14,
		title: "Q14. What is the difference between `val` and `var` in Kotlin?",
		text: undefined,
		code2: "  ",
		choices: [
			"1. `val` is for mutable variables, `var` is for immutable variables.",
			"2. `val` is for immutable variables, `var` is for mutable variables.",
			"3. `val` is for constant variables, `var` is for variables that can be changed.",
			"4. There is no difference.",
		],
		answer: "2. `val` is for immutable variables, `var` is for mutable variables.",
	},
	{
		id: 15,
		title: "Q15. What is the purpose of the `data` keyword in Kotlin?",
		text: undefined,
		code2: "  ",
		choices: [
			"1. It is used to declare a data class.",
			"2. It is used to declare a mutable variable.",
			"3. It is used to declare an immutable variable.",
			"4. It is used to declare a function.",
		],
		answer: "1. It is used to declare a data class.",
	},
	{
		id: 16,
		title: "Q16. What is the output of this Jetpack Compose code?",
		text: undefined,
		code2: '@Composable fun Greeting(name: String) { Text(text = "Hello, $name!") }',
		choices: ["1. Hello, ", "2. Hello, $name!", "3. Hello, [name]", "4. Error"],
		answer: "2. Hello, $name!",
	},
	{
		id: 17,
		title: "Q17. What is the purpose of the `@Composable` annotation in Jetpack Compose?",
		text: undefined,
		code2: "  ",
		choices: [
			"1. It is used to declare a composable function.",
			"2. It is used to declare a mutable variable.",
			"3. It is used to declare an immutable variable.",
			"4. It is used to declare a class.",
		],
		answer: "1. It is used to declare a composable function.",
	},
	
	{
		id: 19,
		title: "Q19. How do you handle permissions in an Android app using Kotlin?",
		text: undefined,
		code2: "  ",
		choices: [
			"1. Use the `requestPermissions` method of the `Context` class.",
			"2. Use the `checkSelfPermission` method of the `Activity` class.",
			"3. Use the `ContextCompat.checkSelfPermission` method and `ActivityCompat.requestPermissions` methods.",
			"4. Use the `PermissionManager` class.",
		],
		answer: "3. Use the `ContextCompat.checkSelfPermission` method and `ActivityCompat.requestPermissions` methods.",
	},
	{
		id: 20,
		title: "Q20. Which of the following is a valid way to start an activity in an Android app using Kotlin?",
		text: undefined,
		code2: "  ",
		choices: [
			"1. `startActivity(Intent(this, SecondActivity::class.java))`",
			"2. `start(SecondActivity::class.java)`",
			"3. `launchActivity(SecondActivity::class.java)`",
			"4. `openActivity(SecondActivity::class.java)`",
		],
		answer: "1. `startActivity(Intent(this, SecondActivity::class.java))`",
	},
	{
		id: 21,
		title: "Q21. How do you navigate between screens in Jetpack Compose?",
		text: undefined,
		code2: "  ",
		choices: [
			"1. Use the `Navigation` class.",
			"2. Use the `startActivity` method.",
			"3. Use the `NavController` class.",
			"4. Use the `FragmentManager` class.",
		],
		answer: "3. Use the `NavController` class.",
	},
	{
		id: 22,
		title: "Q22. What is the purpose of the `ViewModel` class in Android?",
		text: undefined,
		code2: "  ",
		choices: [
			"1. To hold and manage UI state.",
			"2. To handle background tasks.",
			"3. To manage database operations.",
			"4. To handle network requests.",
		],
		answer: "1. To hold and manage UI state.",
	},
	{
		id: 23,
		title: "Q23. What is the purpose of the `Flow` class in Kotlin?",
		text: undefined,
		code2: "  ",
		choices: [
			"1. It is used to represent a sequence of values that can be emitted over time.",
			"2. It is used to perform asynchronous operations.",
			"3. It is used to manage UI state.",
			"4. It is used to handle database operations.",
		],
		answer: "1. It is used to represent a sequence of values that can be emitted over time.",
	},
	{
		id: 24,
		title: "Q24. What is the purpose of the `Room` persistence library in Android?",
		text: undefined,
		code2: "  ",
		choices: [
			"1. To handle background tasks.",
			"2. To manage UI state.",
			"3. To provide an abstraction layer for SQLite.",
			"4. To handle network requests.",
		],
		answer: "3. To provide an abstraction layer for SQLite.",
	},
	{
		id: 25,
		title: "Q25. How do you set up accessibility in an Android app?",
		text: undefined,
		code2: "  ",
		choices: [
			"1. By using the `AccessibilityService` class.",
			"2. By using the `AccessibilityManager` class.",
			"3. By using the `AccessibilityNodeInfo` class.",
			"4. All of the above.",
		],
		answer: "4. All of the above.",
	},
	{
		id: 26,
		title: "Q26. What is the purpose of the `DeviceAdmin` feature in Android?",
		text: undefined,
		code2: "  ",
		choices: [
			"1. To manage system settings and policies.",
			"2. To access user data.",
			"3. To control hardware components.",
			"4. To perform background tasks.",
		],
		answer: "1. To manage system settings and policies.",
	},
	{
		id: 27,
		title: "Q27. How do you set up a `DeviceAdmin` in an Android app?",
		text: undefined,
		code2: "  ",
		choices: [
			"1. By using the `DevicePolicyManager` class.",
			"2. By using the `DeviceAdminReceiver` class.",
			"3. By using the `DeviceAdminService` class.",
			"4. All of the above.",
		],
		answer: "4. All of the above.",
	},
	{
		id: 28,
		title: "Q28. What is the purpose of the `AlarmManager` class in Android?",
		text: undefined,
		code2: "  ",
		choices: [
			"1. To schedule tasks to run at specific times.",
			"2. To manage background tasks.",
			"3. To handle network requests.",
			"4. To provide an abstraction layer for SQLite.",
		],
		answer: "1. To schedule tasks to run at specific times.",
	},
	{
		id: 29,
		title: "Q29. What is the purpose of the `ServiceManager` class in Android?",
		text: undefined,
		code2: "  ",
		choices: [
			"1. To manage background tasks.",
			"2. To handle network requests.",
			"3. To provide an abstraction layer for SQLite.",
			"4. To manage system services.",
		],
		answer: "4. To manage system services.",
	},
	{
		id: 30,
		title: "Q30. How do you create a background service in an Android app using Kotlin?",
		text: undefined,
		code2: "  ",
		choices: [
			"1. By extending the `Service` class.",
			"2. By using the `Job` class.",
			"3. By using the `CoroutineScope` class.",
			"4. All of the above.",
		],
		answer: "1. By extending the `Service` class.",
	},
	{
		id: 31,
		title: "Q31. What is the purpose of the `BroadcastReceiver` class in Android?",
		text: undefined,
		code2: "  ",
		choices: [
			"1. To receive system broadcasts.",
			"2. To send system broadcasts.",
			"3. To handle network requests.",
			"4. To provide an abstraction layer for SQLite.",
		],
		answer: "1. To receive system broadcasts.",
	},
	{
		id: 32,
		title: "Q32. What is the output of this code?",
		text: undefined,
		code2: 'fun main() { val name: String? = null println(name?.length) }',
		choices: ["1. 0", "2. null", "3. Error", "4. 1"],
		answer: "2. null",
	},
	{
		id: 33,
		title: "Q33. What is the output of this code?",
		text: undefined,
		code2: 'fun main() { val list = listOf(1, 2, 3, 4, 5) println(list.take(2)) }',
		choices: ["1. [1, 2, 3]", "2. [1, 2]", "3. [2, 3]", "4. [2, 3, 4]"],
		answer: "2. [1, 2]",
	},
	{
		id: 34,
		title: "Q34. What is the output of this code?",
		text: undefined,
		code2: 'fun main() { val list = listOf(1, 2, 3, 4, 5) println(list.drop(2)) }',
		choices: ["1. [1, 2, 3]", "2. [1, 2]", "3. [3, 4, 5]", "4. [4, 5]"],
		answer: "3. [3, 4, 5]",
	},
	{
		id: 35,
		title: "Q35. What is the output of this code?",
		text: undefined,
		code2: 'fun main() { val list = listOf(1, 2, 3, 4, 5) println(list.takeLast(2)) }',
		choices: ["1. [1, 2]", "2. [3, 4]", "3. [4, 5]", "4. [3, 4, 5]"],
		answer: "3. [4, 5]",
	},
	{
		id: 36,
		title: "Q36. What is the output of this code?",
		text: undefined,
		code2: 'fun main() { val list = listOf(1, 2, 3, 4, 5) println(list.dropLast(2)) }',
		choices: ["1. [1, 2]", "2. [3, 4]", "3. [1, 2, 3]", "4. [1, 2, 3, 4]"],
		answer: "4. [1, 2, 3, 4]",
	},
	{
		id: 37,
		title: "Q37. How do you create a new `CoroutineScope` in Kotlin?",
		text: undefined,
		code2: "  ",
		choices: [
			"1. `CoroutineScope(Dispatchers.IO)`",
			"2. `CoroutineScope()`",
			"3. `CoroutineScope(Dispatchers.Main)`",
			"4. `CoroutineScope(Dispatchers.Default)`",
		],
		answer: "1. `CoroutineScope(Dispatchers.IO)`",
	},
	{
		id: 38,
		title: "Q38. What is the purpose of the `Dispatchers.IO` coroutine dispatcher?",
		text: undefined,
		code2: "  ",
		choices: [
			"1. It is used to run coroutines on the main thread.",
			"2. It is used to run coroutines on a background thread.",
			"3. It is used to run coroutines on a thread pool.",
			"4. It is used to run coroutines on a specific thread.",
		],
		answer: "2. It is used to run coroutines on a background thread.",
	},
	{
		id: 39,
		title: "Q39. What is the purpose of the `Dispatchers.Main` coroutine dispatcher?",
		text: undefined,
		code2: "  ",
		choices: [
			"1. It is used to run coroutines on the main thread.",
			"2. It is used to run coroutines on a background thread.",
			"3. It is used to run coroutines on a thread pool.",
			"4. It is used to run coroutines on a specific thread.",
		],
		answer: "1. It is used to run coroutines on the main thread.",
	},
	{
		id: 40,
		title: "Q40. What is the purpose of the `Dispatchers.Default` coroutine dispatcher?",
		text: undefined,
		code2: "  ",
		choices: [
			"1. It is used to run coroutines on the main thread.",
			"2. It is used to run coroutines on a background thread.",
			"3. It is used to run coroutines on a thread pool.",
			"4. It is used to run coroutines on a specific thread.",
		],
		answer: "3. It is used to run coroutines on a thread pool.",
	},
	{
		id: 41,
		title: "Q41. Which of the following is a valid way to create a `Flow` in Kotlin?",
		text: undefined,
		code2: "  ",
		choices: [
			"1. `flow { emit(1) }`",
			"2. `Flow(1)`",
			"3. `flow(1)`",
			"4. `Flow.create { emit(1) }`",
		],
		answer: "1. `flow { emit(1) }`",
	},
	{
		id: 42,
		title: "Q42. How do you collect a `Flow` in Kotlin?",
		text: undefined,
		code2: "  ",
		choices: [
			"1. `flow.collect { println(it) }`",
			"2. `flow.listen { println(it) }`",
			"3. `flow.subscribe { println(it) }`",
			"4. `flow.observe { println(it) }`",
		],
		answer: "1. `flow.collect { println(it) }`",
	},
	{
		id: 43,
		title: "Q43. What is the purpose of the `launch` function in Kotlin coroutines?",
		text: undefined,
		code2: "  ",
		choices: [
			"1. It is used to launch a new coroutine.",
			"2. It is used to collect a `Flow`.",
			"3. It is used to create a `CoroutineScope`.",
			"4. It is used to manage UI state.",
		],
		answer: "1. It is used to launch a new coroutine.",
	},
	{
		id: 44,
		title: "Q44. How do you create a `Room` database in an Android app using Kotlin?",
		text: undefined,
		code2: "  ",
		choices: [
			"1. By using the `Room.databaseBuilder` method.",
			"2. By using the `SQLiteOpenHelper` class.",
			"3. By using the `ContentProvider` class.",
			"4. By using the `SharedPreferences` class.",
		],
		answer: "1. By using the `Room.databaseBuilder` method.",
	},
	{
		id: 45,
		title: "Q45. How do you define an entity in `Room`?",
		text: undefined,
		code2: "  ",
		choices: [
			"1. By using the `@Entity` annotation.",
			"2. By using the `@Table` annotation.",
			"3. By using the `@Database` annotation.",
			"4. By using the `@Dao` annotation.",
		],
		answer: "1. By using the `@Entity` annotation.",
	},
	{
		id: 46,
		title: "Q46. What is the purpose of a `DAO` in `Room`?",
		text: undefined,
		code2: "  ",
		choices: [
			"1. To define the database schema.",
			"2. To define data access methods.",
			"3. To manage database transactions.",
			"4. All of the above.",
		],
		answer: "2. To define data access methods.",
	},
	{
		id: 47,
		title: "Q47. What is the output of this code?",
		text: undefined,
		code2: 'fun main() { val x = 10 val y = 20 println(x > y) }',
		choices: ["1. true", "2. false", "3. null", "4. 0"],
		answer: "2. false",
	},
	{
		id: 48,
		title: "Q48. What is the output of this code?",
		text: undefined,
		code2: 'fun main() { val x = 10 val y = 20 println(x < y) }',
		choices: ["1. true", "2. false", "3. null", "4. 0"],
		answer: "1. true",
	},
	{
		id: 49,
		title: "Q49. What is the output of this code?",
		text: undefined,
		code2: 'fun main() { val x = 10 val y = 20 println(x == y) }',
		choices: ["1. true", "2. false", "3. null", "4. 0"],
		answer: "2. false",
	},
	{
		id: 50,
		title: "Q50. What is the output of this code?",
		text: undefined,
		code2: 'fun main() { val x = 10 val y = 20 println(x != y) }',
		choices: ["1. true", "2. false", "3. null", "4. 0"],
		answer: "1. true",
	},
	{
		id: 51,
		title: "Q51. What is the output of this code?",
		text: undefined,
		code2: 'fun main() { val x = 10 val y = 20 println(x >= y) }',
		choices: ["1. true", "2. false", "3. null", "4. 0"],
		answer: "2. false",
	},
	{
		id: 52,
		title: "Q52. What is the output of this code?",
		text: undefined,
		code2: 'fun main() { val x = 10 val y = 20 println(x <= y) }',
		choices: ["1. true", "2. false", "3. null", "4. 0"],
		answer: "1. true",
	},
	{
		id: 53,
		title: "Q53. What is the output of this code?",
		text: undefined,
		code2: 'fun main() { val x = 10 val y = 20 println(x + y) }',
		choices: ["1. 10", "2. 20", "3. 30", "4. 1020"],
		answer: "3. 30",
	},
	{
		id: 54,
		title: "Q54. What is the output of this code?",
		text: undefined,
		code2: 'fun main() { val x = 10 val y = 20 println(x - y) }',
		choices: ["1. 10", "2. 20", "3. 30", "4. -10"],
		answer: "4. -10",
	},
	{
		id: 55,
		title: "Q55. What is the output of this code?",
		text: undefined,
		code2: 'fun main() { val x = 10 val y = 20 println(x * y) }',
		choices: ["1. 10", "2. 20", "3. 200", "4. 1020"],
		answer: "3. 200",
	},
	{
		id: 56,
		title: "Q56. What is the output of this code?",
		text: undefined,
		code2: 'fun main() { val x = 10 val y = 20 println(x / y) }',
		choices: ["1. 1", "2. 2", "3. 0.5", "4. 10"],
		answer: "3. 0.5",
	},
	{
		id: 57,
		title: "Q57. What is the output of this code?",
		text: undefined,
		code2: 'fun main() { val x = 10 val y = 20 println(x % y) }',
		choices: ["1. 10", "2. 20", "3. 0", "4. 10"],
		answer: "1. 10",
	},
	{
		id: 58,
		title: "Q58. What is the output of this code?",
		text: undefined,
		code2: 'fun main() { val x = 10 println(x.toString()) }',
		choices: ["1. 10", "2. \"10\"", "3. 10.0", "4. \"10.0\""],
		answer: "2. \"10\"",
	},
	{
		id: 59,
		title: "Q59. What is the output of this code?",
		text: undefined,
		code2: 'fun main() { val x = "10" println(x.toInt()) }',
		choices: ["1. \"10\"", "2. 10.0", "3. 10", "4. Error"],
		answer: "3. 10",
	},
	{
		id: 60,
		title: "Q60. What is the output of this code?",
		text: undefined,
		code2: 'fun main() { val x = 10 println(x.toDouble()) }',
		choices: ["1. 10.0", "2. 10", "3. \"10.0\"", "4. \"10\""],
		answer: "1. 10.0",
	},
	{
		id: 61,
		title: "Q61. What is the output of this code?",
		text: undefined,
		code2: 'fun main() { val x = "10.0" println(x.toFloat()) }',
		choices: ["1. 10.0", "2. 10", "3. \"10.0\"", "4. \"10\""],
		answer: "1. 10.0",
	},
	{
		id: 62,
		title: "Q62. What is the output of this code?",
		text: undefined,
		code2: 'fun main() { val x = 10 val y = 20 println(x == 10 && y == 20) }',
		choices: ["1. true", "2. false", "3. null", "4. 0"],
		answer: "1. true",
	},
	{
		id: 63,
		title: "Q63. What is the output of this code?",
		text: undefined,
		code2: 'fun main() { val x = 10 val y = 20 println(x == 10 || y == 30) }',
		choices: ["1. true", "2. false", "3. null", "4. 0"],
		answer: "1. true",
	},
	
];

// let ds = [
// 	{
// 		id: 1,
// 		title: "# Q1. Which data structure is used to implement a stack?",
// 		text: undefined,
// 		code2: "  ",
// 		choices: [
// 			"1. Linked List",
// 			"2. Array",
// 			"3. Both Linked List and Array",
// 			"4. Tree",
// 		],
// 		answer: "3. Both Linked List and Array",
// 	},
// 	{
// 		id: 2,
// 		title: "# Q2. Which data structure is used to implement a queue?",
// 		text: undefined,
// 		code2: "  ",
// 		choices: [
// 			"1. Linked List",
// 			"2. Array",
// 			"3. Both Linked List and Array",
// 			"4. Graph",
// 		],
// 		answer: "3. Both Linked List and Array",
// 	},
// 	{
// 		id: 3,
// 		title: "# Q3. What is the time complexity of searching an element in a sorted array using binary search?",
// 		text: undefined,
// 		code2: "  ",
// 		choices: ["1. O(n)", "2. O(log n)", "3. O(n log n)", "4. O(1)"],
// 		answer: "2. O(log n)",
// 	},
// 	{
// 		id: 4,
// 		title: "# Q4. What is the time complexity of inserting an element at the beginning of a linked list?",
// 		text: undefined,
// 		code2: "  ",
// 		choices: ["1. O(n)", "2. O(1)", "3. O(log n)", "4. O(n log n)"],
// 		answer: "2. O(1)",
// 	},
// 	{
// 		id: 5,
// 		title: "# Q5. What is the time complexity of deleting an element from the end of a linked list?",
// 		text: undefined,
// 		code2: "  ",
// 		choices: ["1. O(n)", "2. O(1)", "3. O(log n)", "4. O(n log n)"],
// 		answer: "1. O(n)",
// 	},
// 	{
// 		id: 6,
// 		title: "# Q6. What is the time complexity of inserting an element at the end of a queue implemented using an array?",
// 		text: undefined,
// 		code2: "  ",
// 		choices: ["1. O(n)", "2. O(1)", "3. O(log n)", "4. O(n log n)"],
// 		answer: "1. O(n)",
// 	},
// 	// {
// 	// 	id: 7,
// 	// 	title: "# Q7. What is the time complexity of deleting an element from the front of a queue implemented using an array?",
// 	// 	text: undefined,
// 	// 	code2: "  ",
// 	// 	choices: ["1. O(n)", "2. O(1)", "3. O(log n)", "4. O(n log n)"],
// 	// 	answer: "2. O(1)",
// 	// },
// 	{
// 		id: 8,
// 		title: "# Q8. What is the time complexity of inserting an element at the beginning of a stack implemented using a linked list?",
// 		text: undefined,
// 		code2: "  ",
// 		choices: ["1. O(n)", "2. O(1)", "3. O(log n)", "4. O(n log n)"],
// 		answer: "2. O(1)",
// 	},
// 	{
// 		id: 9,
// 		title: "# Q9. What is the time complexity of deleting an element from the top of a stack implemented using a linked list?",
// 		text: undefined,
// 		code2: "  ",
// 		choices: ["1. O(n)", "2. O(1)", "3. O(log n)", "4. O(n log n)"],
// 		answer: "2. O(1)",
// 	},
// 	{
// 		id: 10,
// 		title: "# Q10. What is the time complexity of finding the minimum element in a min-heap?",
// 		text: undefined,
// 		code2: "  ",
// 		choices: ["1. O(n)", "2. O(1)", "3. O(log n)", "4. O(n log n)"],
// 		answer: "2. O(1)",
// 	},
// 	{
// 		id: 11,
// 		title: "# Q11. What is the time complexity of inserting an element into a min-heap?",
// 		text: undefined,
// 		code2: "  ",
// 		choices: ["1. O(n)", "2. O(1)", "3. O(log n)", "4. O(n log n)"],
// 		answer: "3. O(log n)",
// 	},
// 	{
// 		id: 12,
// 		title: "# Q12. What is the time complexity of deleting an element from a min-heap?",
// 		text: undefined,
// 		code2: "  ",
// 		choices: ["1. O(n)", "2. O(1)", "3. O(log n)", "4. O(n log n)"],
// 		answer: "3. O(log n)",
// 	},
// 	// {
// 	// 	id: 13,
// 	// 	title: "# Q13. What is the time complexity of searching for an element in a binary search tree?",
// 	// 	text: undefined,
// 	// 	code2: "  ",
// 	// 	choices: ["1. O(n)", "2. O(1)", "3. O(log n)", "4. O(n log n)"],
// 	// 	answer: "3. O(log n)",
// 	// },
// 	{
// 		id: 14,
// 		title: "# Q14. What is the time complexity of inserting an element into a binary search tree?",
// 		text: undefined,
// 		code2: "  ",
// 		choices: ["1. O(n)", "2. O(1)", "3. O(log n)", "4. O(n log n)"],
// 		answer: "3. O(log n)",
// 	},
// 	{
// 		id: 15,
// 		title: "# Q15. What is the time complexity of deleting an element from a binary search tree?",
// 		text: undefined,
// 		code2: "  ",
// 		choices: ["1. O(n)", "2. O(1)", "3. O(log n)", "4. O(n log n)"],
// 		answer: "3. O(log n)",
// 	},
// 	{
// 		id: 16,
// 		title: "# Q16. What is the time complexity of finding the maximum element in a binary search tree?",
// 		text: undefined,
// 		code2: "  ",
// 		choices: ["1. O(n)", "2. O(1)", "3. O(log n)", "4. O(n log n)"],
// 		answer: "1. O(n)",
// 	},
// 	{
// 		id: 17,
// 		title: "# Q17. What is the time complexity of finding the minimum element in a binary search tree?",
// 		text: undefined,
// 		code2: "  ",
// 		choices: ["1. O(n)", "2. O(1)", "3. O(log n)", "4. O(n log n)"],
// 		answer: "1. O(n)",
// 	},
// 	{
// 		id: 18,
// 		title: "# Q18. What is the time complexity of traversing a binary search tree in inorder?",
// 		text: undefined,
// 		code2: "  ",
// 		choices: ["1. O(n)", "2. O(1)", "3. O(log n)", "4. O(n log n)"],
// 		answer: "1. O(n)",
// 	},
// 	// {
// 	// 	id: 19,
// 	// 	title: "# Q19. What is the time complexity of traversing a binary search tree in preorder?",
// 	// 	text: undefined,
// 	// 	code2: "  ",
// 	// 	choices: ["1. O(n)", "2. O(1)", "3. O(log n)", "4. O(n log n)"],
// 	// 	answer: "1. O(n)",
// 	// },
// 	{
// 		id: 20,
// 		title: "# Q20. What is the time complexity of traversing a binary search tree in postorder?",
// 		text: undefined,
// 		code2: "  ",
// 		choices: ["1. O(n)", "2. O(1)", "3. O(log n)", "4. O(n log n)"],
// 		answer: "1. O(n)",
// 	},
// 	{
// 		id: 21,
// 		title: "# Q21. What is the time complexity of finding the depth of a binary tree?",
// 		text: undefined,
// 		code2: "  ",
// 		choices: ["1. O(n)", "2. O(1)", "3. O(log n)", "4. O(n log n)"],
// 		answer: "1. O(n)",
// 	},
// 	{
// 		id: 22,
// 		title: "# Q22. What is the time complexity of finding the height of a binary tree?",
// 		text: undefined,
// 		code2: "  ",
// 		choices: ["1. O(n)", "2. O(1)", "3. O(log n)", "4. O(n log n)"],
// 		answer: "1. O(n)",
// 	},
// 	{
// 		id: 23,
// 		title: "# Q23. What is the time complexity of finding the diameter of a binary tree?",
// 		text: undefined,
// 		code2: "  ",
// 		choices: ["1. O(n)", "2. O(1)", "3. O(log n)", "4. O(n log n)"],
// 		answer: "1. O(n)",
// 	},
// 	{
// 		id: 24,
// 		title: "# Q24. What is the time complexity of finding the sum of all nodes in a binary tree?",
// 		text: undefined,
// 		code2: "  ",
// 		choices: ["1. O(n)", "2. O(1)", "3. O(log n)", "4. O(n log n)"],
// 		answer: "1. O(n)",
// 	},
// 	{
// 		id: 25,
// 		title: "# Q25. What is the time complexity of finding the number of nodes in a binary tree?",
// 		text: undefined,
// 		code2: "  ",
// 		choices: ["1. O(n)", "2. O(1)", "3. O(log n)", "4. O(n log n)"],
// 		answer: "1. O(n)",
// 	},
// 	{
// 		id: 26,
// 		title: "# Q26. What is the time complexity of finding the level of a node in a binary tree?",
// 		text: undefined,
// 		code2: "  ",
// 		choices: ["1. O(n)", "2. O(1)", "3. O(log n)", "4. O(n log n)"],
// 		answer: "1. O(n)",
// 	},
// 	{
// 		id: 27,
// 		title: "# Q27. What is the time complexity of finding the least common ancestor (LCA) of two nodes in a binary tree?",
// 		text: undefined,
// 		code2: "  ",
// 		choices: ["1. O(n)", "2. O(1)", "3. O(log n)", "4. O(n log n)"],
// 		answer: "1. O(n)",
// 	},
// 	{
// 		id: 28,
// 		title: "# Q28. What is the time complexity of checking if a binary tree is balanced?",
// 		text: undefined,
// 		code2: "  ",
// 		choices: ["1. O(n)", "2. O(1)", "3. O(log n)", "4. O(n log n)"],
// 		answer: "1. O(n)",
// 	},
// 	{
// 		id: 29,
// 		title: "# Q29. What is the time complexity of checking if a binary tree is a binary search tree?",
// 		text: undefined,
// 		code2: "  ",
// 		choices: ["1. O(n)", "2. O(1)", "3. O(log n)", "4. O(n log n)"],
// 		answer: "1. O(n)",
// 	},
// 	{
// 		id: 30,
// 		title: "# Q30. What is the time complexity of checking if a binary tree is a complete binary tree?",
// 		text: undefined,
// 		code2: "  ",
// 		choices: ["1. O(n)", "2. O(1)", "3. O(log n)", "4. O(n log n)"],
// 		answer: "1. O(n)",
// 	},
// 	{
// 		id: 31,
// 		title: "# Q31. What is the time complexity of finding the maximum element in a heap?",
// 		text: undefined,
// 		code2: "  ",
// 		choices: ["1. O(n)", "2. O(1)", "3. O(log n)", "4. O(n log n)"],
// 		answer: "2. O(1)",
// 	},
// 	{
// 		id: 32,
// 		title: "# Q32. What is the time complexity of finding the minimum element in a heap?",
// 		text: undefined,
// 		code2: "  ",
// 		choices: ["1. O(n)", "2. O(1)", "3. O(log n)", "4. O(n log n)"],
// 		answer: "2. O(1)",
// 	},
// 	{
// 		id: 33,
// 		title: "# Q33. What is the time complexity of inserting an element into a heap?",
// 		text: undefined,
// 		code2: "  ",
// 		choices: ["1. O(n)", "2. O(1)", "3. O(log n)", "4. O(n log n)"],
// 		answer: "3. O(log n)",
// 	},
// 	{
// 		id: 34,
// 		title: "# Q34. What is the time complexity of deleting an element from a heap?",
// 		text: undefined,
// 		code2: "  ",
// 		choices: ["1. O(n)", "2. O(1)", "3. O(log n)", "4. O(n log n)"],
// 		answer: "3. O(log n)",
// 	},
// 	{
// 		id: 35,
// 		title: "# Q35. What is the time complexity of sorting an array using merge sort?",
// 		text: undefined,
// 		code2: "  ",
// 		choices: ["1. O(n)", "2. O(n log n)", "3. O(n^2)", "4. O(n^3)"],
// 		answer: "2. O(n log n)",
// 	},
// 	{
// 		id: 36,
// 		title: "# Q36. What is the time complexity of sorting an array using quick sort?",
// 		text: undefined,
// 		code2: "  ",
// 		choices: ["1. O(n)", "2. O(n log n)", "3. O(n^2)", "4. O(n^3)"],
// 		answer: "2. O(n log n)",
// 	},
// 	{
// 		id: 37,
// 		title: "# Q37. What is the time complexity of sorting an array using insertion sort?",
// 		text: undefined,
// 		code2: "  ",
// 		choices: ["1. O(n)", "2. O(n log n)", "3. O(n^2)", "4. O(n^3)"],
// 		answer: "3. O(n^2)",
// 	},
// 	{
// 		id: 38,
// 		title: "# Q38. What is the time complexity of sorting an array using bubble sort?",
// 		text: undefined,
// 		code2: "  ",
// 		choices: ["1. O(n)", "2. O(n log n)", "3. O(n^2)", "4. O(n^3)"],
// 		answer: "3. O(n^2)",
// 	},
// 	{
// 		id: 39,
// 		title: "# Q39. What is the time complexity of sorting an array using selection sort?",
// 		text: undefined,
// 		code2: "  ",
// 		choices: ["1. O(n)", "2. O(n log n)", "3. O(n^2)", "4. O(n^3)"],
// 		answer: "3. O(n^2)",
// 	},
// 	{
// 		id: 40,
// 		title: "# Q40. What is the time complexity of finding the kth smallest element in an unsorted array using the quick select algorithm?",
// 		text: undefined,
// 		code2: "  ",
// 		choices: ["1. O(n)", "2. O(n log n)", "3. O(n^2)", "4. O(n^3)"],
// 		answer: "1. O(n)",
// 	},
// 	{
// 		id: 41,
// 		title: "# Q41. What is the time complexity of finding the kth smallest element in a sorted array?",
// 		text: undefined,
// 		code2: "  ",
// 		choices: ["1. O(n)", "2. O(1)", "3. O(log n)", "4. O(n log n)"],
// 		answer: "2. O(1)",
// 	},
// 	{
// 		id: 42,
// 		title: "# Q42. What is the time complexity of finding the median of an unsorted array?",
// 		text: undefined,
// 		code2: "  ",
// 		choices: ["1. O(n)", "2. O(n log n)", "3. O(n^2)", "4. O(n^3)"],
// 		answer: "1. O(n)",
// 	},
// 	{
// 		id: 43,
// 		title: "# Q43. What is the time complexity of finding the median of a sorted array?",
// 		text: undefined,
// 		code2: "  ",
// 		choices: ["1. O(n)", "2. O(1)", "3. O(log n)", "4. O(n log n)"],
// 		answer: "2. O(1)",
// 	},
// 	{
// 		id: 44,
// 		title: "# Q44. What is the time complexity of finding the mode of an unsorted array?",
// 		text: undefined,
// 		code2: "  ",
// 		choices: ["1. O(n)", "2. O(n log n)", "3. O(n^2)", "4. O(n^3)"],
// 		answer: "1. O(n)",
// 	},
// 	{
// 		id: 45,
// 		title: "# Q45. What is the time complexity of finding the mode of a sorted array?",
// 		text: undefined,
// 		code2: "  ",
// 		choices: ["1. O(n)", "2. O(1)", "3. O(log n)", "4. O(n log n)"],
// 		answer: "1. O(n)",
// 	},
// 	{
// 		id: 46,
// 		title: "# Q46. What is the time complexity of finding the range of an unsorted array?",
// 		text: undefined,
// 		code2: "  ",
// 		choices: ["1. O(n)", "2. O(1)", "3. O(log n)", "4. O(n log n)"],
// 		answer: "1. O(n)",
// 	},
// 	{
// 		id: 47,
// 		title: "# Q47. What is the time complexity of finding the range of a sorted array?",
// 		text: undefined,
// 		code2: "  ",
// 		choices: ["1. O(n)", "2. O(1)", "3. O(log n)", "4. O(n log n)"],
// 		answer: "2. O(1)",
// 	},
// 	{
// 		id: 48,
// 		title: "# Q48. What is the time complexity of finding the sum of all elements in an unsorted array?",
// 		text: undefined,
// 		code2: "  ",
// 		choices: ["1. O(n)", "2. O(1)", "3. O(log n)", "4. O(n log n)"],
// 		answer: "1. O(n)",
// 	},
// 	{
// 		id: 49,
// 		title: "# Q49. What is the time complexity of finding the sum of all elements in a sorted array?",
// 		text: undefined,
// 		code2: "  ",
// 		choices: ["1. O(n)", "2. O(1)", "3. O(log n)", "4. O(n log n)"],
// 		answer: "1. O(n)",
// 	},
// 	{
// 		id: 50,
// 		title: "# Q50. What is the time complexity of finding the average of all elements in an unsorted array?",
// 		text: undefined,
// 		code2: "  ",
// 		choices: ["1. O(n)", "2. O(1)", "3. O(log n)", "4. O(n log n)"],
// 		answer: "1. O(n)",
// 	},

// 	{
// 		id: 51,
// 		title: "# Q51. Which of the following is NOT a valid data structure?",
// 		text: undefined,
// 		code2: "  ",
// 		choices: ["1. Queue", "2. Stack", "3. Heap", "4. Loop"],
// 		answer: "4. Loop",
// 	},
// 	{
// 		id: 52,
// 		title: "# Q52. What is the primary difference between a stack and a queue?",
// 		text: undefined,
// 		code2: "  ",
// 		choices: [
// 			"1. Stacks are LIFO, queues are FIFO.",
// 			"2. Stacks are FIFO, queues are LIFO.",
// 			"3. Stacks use arrays, queues use linked lists.",
// 			"4. Stacks use linked lists, queues use arrays.",
// 		],
// 		answer: "1. Stacks are LIFO, queues are FIFO.",
// 	},
// 	{
// 		id: 53,
// 		title: "# Q53. Which of the following is an advantage of using a linked list over an array?",
// 		text: undefined,
// 		code2: "  ",
// 		choices: [
// 			"1. Faster insertion and deletion at arbitrary positions.",
// 			"2. More efficient memory usage.",
// 			"3. Easier to implement.",
// 			"4. All of the above.",
// 		],
// 		answer: "1. Faster insertion and deletion at arbitrary positions.",
// 	},
// 	{
// 		id: 54,
// 		title: "# Q54. What is the time complexity of accessing the kth element in an array?",
// 		text: undefined,
// 		code2: "  ",
// 		choices: ["1. O(n)", "2. O(1)", "3. O(log n)", "4. O(n log n)"],
// 		answer: "2. O(1)",
// 	},
// 	// {
// 	// 	id: 55,
// 	// 	title: "# Q55. Which of the following is NOT a sorting algorithm?",
// 	// 	text: undefined,
// 	// 	code2: "  ",
// 	// 	choices: [
// 	// 		"1. Merge Sort",
// 	// 		"2. Quick Sort",
// 	// 		"3. Binary Search",
// 	// 		"4. Insertion Sort",
// 	// 	],
// 	// 	answer: "3. Binary Search",
// 	// },
// 	{
// 		id: 56,
// 		title: "# Q56. Which sorting algorithm is generally considered the most efficient for large datasets?",
// 		text: undefined,
// 		code2: "  ",
// 		choices: [
// 			"1. Bubble Sort",
// 			"2. Insertion Sort",
// 			"3. Merge Sort",
// 			"4. Selection Sort",
// 		],
// 		answer: "3. Merge Sort",
// 	},
// 	{
// 		id: 57,
// 		title: "# Q57. What is the time complexity of the best-case scenario for Quick Sort?",
// 		text: undefined,
// 		code2: "  ",
// 		choices: ["1. O(n)", "2. O(n log n)", "3. O(n^2)", "4. O(n^3)"],
// 		answer: "2. O(n log n)",
// 	},
// 	// {
// 	// 	id: 58,
// 	// 	title: "# Q58. What is the worst-case time complexity of Heap Sort?",
// 	// 	text: undefined,
// 	// 	code2: "  ",
// 	// 	choices: ["1. O(n)", "2. O(n log n)", "3. O(n^2)"],
// 	// },

// 	{
// 		id: 51,
// 		title: "# Q51. Which of the following is NOT a valid data structure?",
// 		text: undefined,
// 		code2: "  ",
// 		choices: ["1. Queue", "2. Stack", "3. Heap", "4. Loop"],
// 		answer: "4. Loop",
// 		solution:
// 			"A loop is a control flow construct, not a data structure. Data structures are designed to organize and store data, while loops are used to repeat a block of code.",
// 	},
// 	{
// 		id: 52,
// 		title: "# Q52. What is the primary difference between a stack and a queue?",
// 		text: undefined,
// 		code2: "  ",
// 		choices: [
// 			"1. Stacks are LIFO, queues are FIFO.",
// 			"2. Stacks are FIFO, queues are LIFO.",
// 			"3. Stacks use arrays, queues use linked lists.",
// 			"4. Stacks use linked lists, queues use arrays.",
// 		],
// 		answer: "1. Stacks are LIFO, queues are FIFO.",
// 		solution:
// 			"LIFO stands for Last-In, First-Out. In a stack, the last element added is the first one to be removed. FIFO stands for First-In, First-Out. In a queue, the first element added is the first one to be removed.",
// 	},
// 	{
// 		id: 53,
// 		title: "# Q53. Which of the following is an advantage of using a linked list over an array?",
// 		text: undefined,
// 		code2: "  ",
// 		choices: [
// 			"1. Faster insertion and deletion at arbitrary positions.",
// 			"2. More efficient memory usage.",
// 			"3. Easier to implement.",
// 			"4. All of the above.",
// 		],
// 		answer: "1. Faster insertion and deletion at arbitrary positions.",
// 		solution:
// 			"In a linked list, elements are stored in nodes that point to each other. To insert or delete an element, you only need to change the pointers, which is a constant-time operation. In an array, you need to shift elements to make space for insertion or deletion, which takes linear time.",
// 	},
// 	{
// 		id: 54,
// 		title: "# Q54. What is the time complexity of accessing the kth element in an array?",
// 		text: undefined,
// 		code2: "  ",
// 		choices: ["1. O(n)", "2. O(1)", "3. O(log n)", "4. O(n log n)"],
// 		answer: "2. O(1)",
// 		solution:
// 			"Accessing an element in an array is done by directly indexing it, which takes constant time regardless of the size of the array.",
// 	},
// 	{
// 		id: 55,
// 		title: "# Q55. Which of the following is NOT a sorting algorithm?",
// 		text: undefined,
// 		code2: "  ",
// 		choices: [
// 			"1. Merge Sort",
// 			"2. Quick Sort",
// 			"3. Binary Search",
// 			"4. Insertion Sort",
// 		],
// 		answer: "3. Binary Search",
// 		solution:
// 			"Binary search is a search algorithm, not a sorting algorithm. It is used to efficiently find a specific element in a sorted array.",
// 	},
// 	{
// 		id: 56,
// 		title: "# Q56. Which sorting algorithm is generally considered the most efficient for large datasets?",
// 		text: undefined,
// 		code2: "  ",
// 		choices: [
// 			"1. Bubble Sort",
// 			"2. Insertion Sort",
// 			"3. Merge Sort",
// 			"4. Selection Sort",
// 		],
// 		answer: "3. Merge Sort",
// 		solution:
// 			"Merge sort has a time complexity of O(n log n) for all cases, making it a very efficient sorting algorithm for large datasets. While other algorithms like Quick Sort might be faster in some scenarios, Merge Sort's consistency and predictable performance make it the preferred choice for large data.",
// 	},
// 	{
// 		id: 57,
// 		title: "# Q57. What is the time complexity of the best-case scenario for Quick Sort?",
// 		text: undefined,
// 		code2: "  ",
// 		choices: ["1. O(n)", "2. O(n log n)", "3. O(n^2)", "4. O(n^3)"],
// 		answer: "2. O(n log n)",
// 		solution:
// 			"Quick Sort's best-case scenario occurs when the pivot element selected in each partition step divides the array into roughly equal halves. In this case, the algorithm performs very efficiently with a time complexity of O(n log n).",
// 	},
// 	{
// 		id: 58,
// 		title: "# Q58. What is the worst-case time complexity of Heap Sort?",
// 		text: undefined,
// 		code2: "  ",
// 		choices: ["1. O(n)", "2. O(n log n)", "3. O(n^2)", "4. O(n^3)"],
// 		answer: "2. O(n log n)",
// 		solution:
// 			"Heap Sort consistently maintains a time complexity of O(n log n) for both best-case and worst-case scenarios. It's known for its stable performance, making it a reliable choice even for potentially challenging datasets.",
// 	},
// 	{
// 		id: 59,
// 		title: "# Q59. Which data structure is used in the implementation of a priority queue?",
// 		text: undefined,
// 		code2: "  ",
// 		choices: ["1. Linked List", "2. Array", "3. Heap", "4. Stack"],
// 		answer: "3. Heap",
// 		solution:
// 			"Heaps are typically used to implement priority queues because they allow for efficient insertion and deletion operations while maintaining the priority order of elements. Heaps ensure that the element with the highest (or lowest) priority is always at the root, making it easily accessible for retrieval.",
// 	},
// 	{
// 		id: 60,
// 		title: "# Q60. What is the time complexity of searching for an element in a hash table?",
// 		text: undefined,
// 		code2: "  ",
// 		choices: ["1. O(n)", "2. O(1)", "3. O(log n)", "4. O(n log n)"],
// 		answer: "2. O(1)",
// 		solution:
// 			"In an ideal hash table, the average time complexity for searching is O(1), meaning that it takes a constant amount of time to locate an element, regardless of the table size. This efficiency stems from the way elements are stored and accessed using hash functions.",
// 	},
// 	{
// 		id: 61,
// 		title: "# Q61. What is a hash function?",
// 		text: undefined,
// 		code2: "  ",
// 		choices: [
// 			"1. A function that generates a unique key for each element.",
// 			"2. A function that sorts elements in ascending order.",
// 			"3. A function that searches for a specific element in a data structure.",
// 			"4. A function that deletes an element from a data structure.",
// 		],
// 		answer: "1. A function that generates a unique key for each element.",
// 		solution:
// 			"A hash function maps data of arbitrary size to a fixed-size value, known as a hash value. This hash value is used to store and retrieve elements in a hash table. Ideally, a good hash function should distribute the hash values evenly, minimizing collisions and improving search performance.",
// 	},
// 	{
// 		id: 62,
// 		title: "# Q62. What is a collision in a hash table?",
// 		text: undefined,
// 		code2: "  ",
// 		choices: [
// 			"1. When two different elements map to the same hash value.",
// 			"2. When a hash function fails to generate a unique key.",
// 			"3. When the hash table is full and cannot store more elements.",
// 			"4. When the hash function returns a negative hash value.",
// 		],
// 		answer: "1. When two different elements map to the same hash value.",
// 		solution:
// 			"Collisions occur when two distinct elements produce the same hash value. This can happen even with well-designed hash functions, especially when dealing with a large number of elements. Collision resolution techniques like separate chaining or open addressing are used to handle such situations and avoid data loss or overwriting.",
// 	},
// 	{
// 		id: 63,
// 		title: "# Q63. What is a graph?",
// 		text: undefined,
// 		code2: "  ",
// 		choices: [
// 			"1. A data structure that represents a hierarchical relationship between elements.",
// 			"2. A data structure that represents a network of interconnected nodes.",
// 			"3. A data structure that stores elements in a sorted order.",
// 			"4. A data structure that stores elements in a LIFO manner.",
// 		],
// 		answer: "2. A data structure that represents a network of interconnected nodes.",
// 		solution:
// 			"A graph consists of nodes (also known as vertices) and edges that connect these nodes. It's used to model relationships and connections between entities, making it suitable for representing networks, maps, social connections, dependencies, and various other real-world scenarios.",
// 	},
// 	{
// 		id: 64,
// 		title: "# Q64. What is a tree?",
// 		text: undefined,
// 		code2: "  ",
// 		choices: [
// 			"1. A data structure that represents a network of interconnected nodes.",
// 			"2. A data structure that represents a hierarchical relationship between elements.",
// 			"3. A data structure that stores elements in a sorted order.",
// 			"4. A data structure that stores elements in a LIFO manner.",
// 		],
// 		answer: "2. A data structure that represents a hierarchical relationship between elements.",
// 		solution:
// 			"Trees are a hierarchical data structure where elements are organized in a parent-child relationship. The topmost node is called the root, and each node can have multiple child nodes. This structure allows for efficient traversal and search operations, making it suitable for applications like file systems, databases, and decision-making.",
// 	},
// 	{
// 		id: 65,
// 		title: "# Q65. What is the difference between a directed graph and an undirected graph?",
// 		text: undefined,
// 		code2: "  ",
// 		choices: [
// 			"1. Directed graphs have edges with a specific direction, while undirected graphs do not.",
// 			"2. Undirected graphs have edges with a specific direction, while directed graphs do not.",
// 			"3. Directed graphs are used to represent hierarchies, while undirected graphs are used to represent networks.",
// 			"4. Undirected graphs are used to represent hierarchies, while directed graphs are used to represent networks.",
// 		],
// 		answer: "1. Directed graphs have edges with a specific direction, while undirected graphs do not.",
// 		solution:
// 			"In a directed graph, the edges represent one-way connections between nodes. For example, a road network with one-way streets can be modeled as a directed graph. In an undirected graph, edges represent two-way connections between nodes. For example, a social network where individuals can be friends with each other can be represented as an undirected graph.",
// 	},
// 	{
// 		id: 66,
// 		title: "# Q66. What is a binary tree?",
// 		text: undefined,
// 		code2: "  ",
// 		choices: [
// 			"1. A tree where each node can have at most two child nodes.",
// 			"2. A tree where each node can have at most one child node.",
// 			"3. A tree where each node can have any number of child nodes.",
// 			"4. A tree where each node is a binary number.",
// 		],
// 		answer: "1. A tree where each node can have at most two child nodes.",
// 		solution:
// 			"A binary tree is a type of tree data structure where each node has a maximum of two child nodes, typically labeled as the left child and the right child. This structure allows for efficient organization and retrieval of data based on certain criteria, making it a popular choice for implementing search algorithms, sorting, and expression trees.",
// 	},
// 	{
// 		id: 67,
// 		title: "# Q67. What is a complete binary tree?",
// 		text: undefined,
// 		code2: "  ",
// 		choices: [
// 			"1. A binary tree where all levels are completely filled except possibly the last level.",
// 			"2. A binary tree where all levels are completely filled.",
// 			"3. A binary tree where the left subtree is a complete binary tree and the right subtree is a complete binary tree.",
// 			"4. A binary tree where all nodes have a maximum of two children.",
// 		],
// 		answer: "1. A binary tree where all levels are completely filled except possibly the last level.",
// 		solution:
// 			"In a complete binary tree, all levels are completely filled with nodes, except possibly the last level. On the last level, all nodes are as far left as possible. This property makes complete binary trees particularly efficient for storing and retrieving elements, as they provide a compact and organized structure.",
// 	},
// 	{
// 		id: 68,
// 		title: "# Q68. What is a perfect binary tree?",
// 		text: undefined,
// 		code2: "  ",
// 		choices: [
// 			"1. A binary tree where all levels are completely filled.",
// 			"2. A binary tree where all levels are completely filled except possibly the last level.",
// 			"3. A binary tree where the left subtree is a perfect binary tree and the right subtree is a perfect binary tree.",
// 			"4. A binary tree where all nodes have a maximum of two children.",
// 		],
// 		answer: "1. A binary tree where all levels are completely filled.",
// 		solution:
// 			"A perfect binary tree has all levels completely filled with nodes. It's a specific type of complete binary tree where every node, except for the leaves, has exactly two children. This structure provides maximum space utilization and efficiency for certain algorithms like heap sort.",
// 	},
// 	// {
// 	// 	id: 69,
// 	// 	title: "# Q69. What is a balanced binary tree?",
// 	// 	text: undefined,
// 	// 	code2: "  ",
// 	// 	choices: [
// 	// 		"1. A binary tree where the left and right subtrees have the same height.",
// 	// 		"2. A binary tree where the left subtree is a balanced binary tree and the right subtree is a balanced binary tree.",
// 	// 		"3. A binary tree where all nodes have a maximum of two children.",
// 	// 		"4. A binary tree where the height of the left subtree is at most one greater than the height of the right subtree, or vice versa.",
// 	// 	],
// 	// 	answer: "4. A binary tree where the height of the left subtree is at most one greater than the height of the right subtree, or vice versa.",
// 	// 	solution:
// 	// 		"A balanced binary tree is a binary tree where the difference in heights between the left and right subtrees of any node is at most one. This ensures that the tree is relatively 'well-shaped' and prevents it from becoming too skewed, which could lead to poor performance for search and insertion operations. Common examples of self-balancing binary trees include AVL trees and red-black trees.",
// 	// },
// 	{
// 		id: 70,
// 		title: "# Q70. What is the purpose of a self-balancing binary search tree?",
// 		text: undefined,
// 		code2: "  ",
// 		choices: [
// 			"1. To ensure that the tree is always balanced, even after insertions and deletions.",
// 			"2. To improve the efficiency of search operations.",
// 			"3. To prevent the tree from becoming too skewed.",
// 			"4. All of the above.",
// 		],
// 		answer: "4. All of the above.",
// 		solution:
// 			"Self-balancing binary search trees are designed to maintain a balanced structure even as elements are inserted or deleted. This balance ensures that the worst-case time complexity for search, insertion, and deletion operations remains O(log n), preventing the tree from degenerating into a linear structure and significantly slowing down operations.",
// 	},
// 	{
// 		id: 71,
// 		title: "# Q71. Which of the following is NOT a self-balancing binary search tree?",
// 		text: undefined,
// 		code2: "  ",
// 		choices: [
// 			"1. AVL Tree",
// 			"2. Red-Black Tree",
// 			"3. B-Tree",
// 			"4. Splay Tree",
// 		],
// 		answer: "3. B-Tree",
// 		solution:
// 			"B-Trees are a type of balanced tree, but they are not specifically designed for self-balancing in the context of binary search trees. They are primarily used for efficient storage and retrieval of data on disk, often found in databases.",
// 	},
// 	{
// 		id: 72,
// 		title: "# Q72. What is the purpose of a trie?",
// 		text: undefined,
// 		code2: "  ",
// 		choices: [
// 			"1. To efficiently store and retrieve strings.",
// 			"2. To sort elements in alphabetical order.",
// 			"3. To search for a specific element in a data structure.",
// 			"4. To delete an element from a data structure.",
// 		],
// 		answer: "1. To efficiently store and retrieve strings.",
// 		solution:
// 			"Tries, also known as prefix trees, are specialized tree structures optimized for storing and searching strings. Each node in a trie represents a character, and the path from the root to a leaf node represents a complete string. Tries allow for efficient prefix-based searching, making them suitable for applications like autocomplete, spell checkers, and dictionary implementations.",
// 	},

// 	{
// 		id: 74,
// 		title: "# Q74. What is the time complexity of the union operation in a disjoint set data structure?",
// 		text: undefined,
// 		code2: "  ",
// 		choices: ["1. O(n)", "2. O(1)", "3. O(log n)", "4. O(n log n)"],
// 		answer: "3. O(log n)",
// 		solution:
// 			"The time complexity of the union operation in a disjoint set data structure is typically O(log n), where n is the number of elements in the sets being merged. This is achieved through efficient techniques like path compression and union by rank.",
// 	},
// 	{
// 		id: 75,
// 		title: "# Q75. What is the time complexity of the find operation in a disjoint set data structure?",
// 		text: undefined,
// 		code2: "  ",
// 		choices: ["1. O(n)", "2. O(1)", "3. O(log n)", "4. O(n log n)"],
// 		answer: "3. O(log n)",
// 		solution:
// 			"Similar to the union operation, the find operation in a disjoint set data structure typically has a time complexity of O(log n) using techniques like path compression and union by rank.",
// 	},
// 	{
// 		id: 76,
// 		title: "# Q76. Which data structure is used to represent a game tree in artificial intelligence?",
// 		text: undefined,
// 		code2: "  ",
// 		choices: ["1. Stack", "2. Queue", "3. Heap", "4. Tree"],
// 		answer: "4. Tree",
// 		solution:
// 			"Game trees are commonly used in artificial intelligence to represent the possible moves and outcomes in a game. Each node in the tree represents a game state, and the edges represent the possible moves that can be made from that state. This structure allows for algorithms like minimax and alpha-beta pruning to search for optimal moves in the game.",
// 	},
// 	{
// 		id: 77,
// 		title: "# Q77. What is the purpose of a breadth-first search (BFS) algorithm?",
// 		text: undefined,
// 		code2: "  ",
// 		choices: [
// 			"1. To find the shortest path between two nodes in a graph.",
// 			"2. To find the maximum element in a graph.",
// 			"3. To sort elements in alphabetical order.",
// 			"4. To delete an element from a graph.",
// 		],
// 		answer: "1. To find the shortest path between two nodes in a graph.",
// 		solution:
// 			"BFS is a graph traversal algorithm that explores the graph level by level, starting from a source node. It is used to find the shortest path between two nodes in an unweighted graph or to determine if there is a path between two nodes. BFS is often used in applications like network routing, finding the shortest path in a maze, and discovering connected components in a graph.",
// 	},
// 	{
// 		id: 78,
// 		title: "# Q78. What is the purpose of a depth-first search (DFS) algorithm?",
// 		text: undefined,
// 		code2: "  ",
// 		choices: [
// 			"1. To find the shortest path between two nodes in a graph.",
// 			"2. To find all reachable nodes from a given source node.",
// 			"3. To sort elements in alphabetical order.",
// 			"4. To delete an element from a graph.",
// 		],
// 		answer: "2. To find all reachable nodes from a given source node.",
// 		solution:
// 			"DFS is a graph traversal algorithm that explores the graph by going as deep as possible along each branch before backtracking. It is used to find all reachable nodes from a given source node, determine if a graph is cyclic, or find connected components in a graph. DFS is often used in applications like topological sorting, finding cycles in a graph, and solving puzzles like Sudoku.",
// 	},
// 	{
// 		id: 79,
// 		title: "# Q79. What is the time complexity of a breadth-first search (BFS) algorithm?",
// 		text: undefined,
// 		code2: "  ",
// 		choices: ["1. O(n)", "2. O(V+E)", "3. O(log n)", "4. O(n log n)"],
// 		answer: "2. O(V+E)",
// 		solution:
// 			"The time complexity of BFS is O(V+E), where V is the number of vertices (nodes) and E is the number of edges in the graph. BFS visits each vertex once and explores each edge once, making its runtime proportional to the size of the graph.",
// 	},
// 	{
// 		id: 80,
// 		title: "# Q80. What is the time complexity of a depth-first search (DFS) algorithm?",
// 		text: undefined,
// 		code2: "  ",
// 		choices: ["1. O(n)", "2. O(V+E)", "3. O(log n)", "4. O(n log n)"],
// 		answer: "2. O(V+E)",
// 		solution:
// 			"Similar to BFS, the time complexity of DFS is also O(V+E), where V is the number of vertices and E is the number of edges. DFS visits each vertex once and explores each edge once, making its runtime proportional to the size of the graph.",
// 	},
// 	{
// 		id: 81,
// 		title: "# Q81. What is Dijkstra's algorithm?",
// 		text: undefined,
// 		code2: "  ",
// 		choices: [
// 			"1. A graph traversal algorithm.",
// 			"2. A sorting algorithm.",
// 			"3. An algorithm for finding the shortest path between two nodes in a weighted graph.",
// 			"4. An algorithm for finding the minimum spanning tree of a graph.",
// 		],
// 		answer: "3. An algorithm for finding the shortest path between two nodes in a weighted graph.",
// 		solution:
// 			"Dijkstra's algorithm is a greedy algorithm that finds the shortest path from a source node to all other nodes in a weighted graph. It works by iteratively selecting the node with the smallest distance from the source node and updating the distances of its neighboring nodes. Dijkstra's algorithm is widely used in applications like route planning, network routing, and finding the shortest paths in maps.",
// 	},
// 	{
// 		id: 82,
// 		title: "# Q82. What is the time complexity of Dijkstra's algorithm?",
// 		text: undefined,
// 		code2: "  ",
// 		choices: ["1. O(n)", "2. O(V+E)", "3. O(V log V)", "4. O(n log n)"],
// 		answer: "3. O(V log V)",
// 		solution:
// 			"The time complexity of Dijkstra's algorithm is typically O(V log V), where V is the number of vertices in the graph. This is achieved using a priority queue to efficiently select the node with the smallest distance from the source node. The use of a priority queue allows for faster updates and retrieval of distances, leading to the overall complexity of O(V log V).",
// 	},
// 	{
// 		id: 83,
// 		title: "# Q83. What is the purpose of Kruskal's algorithm?",
// 		text: undefined,
// 		code2: "  ",
// 		choices: [
// 			"1. To find the shortest path between two nodes in a graph.",
// 			"2. To find the minimum spanning tree of a graph.",
// 			"3. To sort elements in alphabetical order.",
// 			"4. To delete an element from a graph.",
// 		],
// 		answer: "2. To find the minimum spanning tree of a graph.",
// 		solution:
// 			"Kruskal's algorithm is a greedy algorithm that finds the minimum spanning tree (MST) of a connected, undirected graph. It works by iteratively selecting the edge with the smallest weight that does not create a cycle in the MST. Kruskal's algorithm uses a disjoint set data structure to efficiently determine if adding an edge will create a cycle. It is often used in applications like network design, circuit design, and transportation networks.",
// 	},
// 	{
// 		id: 84,
// 		title: "# Q84. What is the time complexity of Kruskal's algorithm?",
// 		text: undefined,
// 		code2: "  ",
// 		choices: ["1. O(n)", "2. O(V+E)", "3. O(E log E)", "4. O(n log n)"],
// 		answer: "3. O(E log E)",
// 		solution:
// 			"Kruskal's algorithm's time complexity is O(E log E), where E is the number of edges in the graph. This is due to sorting the edges in ascending order of weight (which takes O(E log E) time) and using a disjoint set data structure for the union-find operations, which takes O(E log E) time as well. The overall complexity is dominated by these two operations, resulting in an overall time complexity of O(E log E).",
// 	},
// 	{
// 		id: 85,
// 		title: "# Q85. What is the purpose of Prim's algorithm?",
// 		text: undefined,
// 		code2: "  ",
// 		choices: [
// 			"1. To find the shortest path between two nodes in a graph.",
// 			"2. To find the minimum spanning tree of a graph.",
// 			"3. To sort elements in alphabetical order.",
// 			"4. To delete an element from a graph.",
// 		],
// 		answer: "2. To find the minimum spanning tree of a graph.",
// 		solution:
// 			"Prim's algorithm is another greedy algorithm that finds the minimum spanning tree (MST) of a connected, undirected graph. It works by iteratively adding the edge with the smallest weight that connects a node in the MST to a node outside the MST. Prim's algorithm uses a priority queue to efficiently select the edge with the smallest weight. It is also widely used in applications like network design, circuit design, and transportation networks.",
// 	},
// 	{
// 		id: 86,
// 		title: "# Q86. What is the time complexity of Prim's algorithm?",
// 		text: undefined,
// 		code2: "  ",
// 		choices: ["1. O(n)", "2. O(V+E)", "3. O(E log E)", "4. O(V log V)"],
// 		answer: "4. O(V log V)",
// 		solution:
// 			"The time complexity of Prim's algorithm is typically O(V log V), where V is the number of vertices in the graph. This is achieved using a priority queue to efficiently select the edge with the smallest weight. The use of a priority queue allows for faster updates and retrieval of edge weights, leading to the overall complexity of O(V log V).",
// 	},
// 	{
// 		id: 87,
// 		title: "# Q87. What is the difference between Kruskal's algorithm and Prim's algorithm?",
// 		text: undefined,
// 		code2: "  ",
// 		choices: [
// 			"1. Kruskal's algorithm uses a disjoint set data structure, while Prim's algorithm uses a priority queue.",
// 			"2. Kruskal's algorithm starts with a single node and adds edges iteratively, while Prim's algorithm starts with a single edge and adds nodes iteratively.",
// 			"3. Kruskal's algorithm has a time complexity of O(E log E), while Prim's algorithm has a time complexity of O(V log V).",
// 			"4. All of the above.",
// 		],
// 		answer: "4. All of the above.",
// 		solution:
// 			"While both Kruskal's algorithm and Prim's algorithm find the minimum spanning tree of a graph, they have different approaches",
// 	},
// 	{
// 		id: 88,
// 		title: "# Q88. What is a topological sort?",
// 		text: undefined,
// 		code2: "  ",
// 		choices: [
// 			"1. A sorting algorithm for directed graphs.",
// 			"2. A graph traversal algorithm.",
// 			"3. An algorithm for finding the shortest path between two nodes in a graph.",
// 			"4. An algorithm for finding the minimum spanning tree of a graph.",
// 		],
// 		answer: "1. A sorting algorithm for directed graphs.",
// 		solution:
// 			"Topological sort is a linear ordering of vertices in a directed acyclic graph (DAG) such that for every directed edge (u, v), vertex u comes before vertex v in the ordering. It is used in applications like task scheduling, dependency management, and resolving circular dependencies in code.",
// 	},
// 	{
// 		id: 89,
// 		title: "# Q89. What is the time complexity of a topological sort algorithm?",
// 		text: undefined,
// 		code2: "  ",
// 		choices: ["1. O(n)", "2. O(V+E)", "3. O(log n)", "4. O(n log n)"],
// 		answer: "2. O(V+E)",
// 		solution:
// 			"The time complexity of a topological sort algorithm is typically O(V+E), where V is the number of vertices and E is the number of edges in the directed acyclic graph. This is because the algorithm visits each vertex and edge at most once, making its runtime proportional to the size of the graph.",
// 	},
// 	{
// 		id: 90,
// 		title: "# Q90. What is the purpose of a dynamic programming algorithm?",
// 		text: undefined,
// 		code2: "  ",
// 		choices: [
// 			"1. To solve problems by breaking them down into smaller overlapping subproblems and storing the solutions to these subproblems.",
// 			"2. To sort elements in alphabetical order.",
// 			"3. To search for a specific element in a data structure.",
// 			"4. To delete an element from a data structure.",
// 		],
// 		answer: "1. To solve problems by breaking them down into smaller overlapping subproblems and storing the solutions to these subproblems.",
// 		solution:
// 			"Dynamic programming is a technique for solving problems by breaking them down into smaller overlapping subproblems and storing the solutions to these subproblems to avoid recomputing them. This approach helps to optimize the overall runtime of the algorithm by reusing previously calculated results. Dynamic programming is used in various applications like finding the shortest path in a graph, calculating Fibonacci numbers, and solving knapsack problems.",
// 	},
// 	{
// 		id: 91,
// 		title: "# Q91. Which of the following is NOT a dynamic programming problem?",
// 		text: undefined,
// 		code2: "  ",
// 		choices: [
// 			"1. Fibonacci sequence",
// 			"2. Knapsack problem",
// 			"3. Traveling salesman problem",
// 			"4. Merge Sort",
// 		],
// 		answer: "4. Merge Sort",
// 		solution:
// 			"Merge Sort is a divide-and-conquer algorithm, not a dynamic programming algorithm. It does not store or reuse previously calculated results like dynamic programming.",
// 	},

// 	{
// 		id: 92,
// 		title: "# Q92. Given a sorted array, return the index of the first occurrence of a target value.",
// 		text: undefined,
// 		code2: "```cpp<br>int firstOccurrence(vector<int>& nums, int target) {<br>  // Implement the logic here<br>}<br>```",
// 		choices: [
// 			"1. `return -1;`",
// 			"2. `return 0;`",
// 			"3. `return nums.size() - 1;`",
// 			"4. `return lower_bound(nums.begin(), nums.end(), target) - nums.begin();` ",
// 		],
// 		answer: "4. `return lower_bound(nums.begin(), nums.end(), target) - nums.begin();` ",
// 		solution:
// 			"The `lower_bound` function in C++ returns an iterator to the first element in the range that is not less than the given value.  Subtracting the beginning iterator gives us the index of that element, which represents the first occurrence of the target value in the sorted array.  If the target value is not present in the array, `lower_bound` returns an iterator to the end of the array.  Since we're looking for the first occurrence, we subtract the beginning iterator, resulting in an index equal to the size of the array, which is effectively the same as returning -1.",
// 	},
// 	{
// 		id: 93,
// 		title: "# Q93. Reverse a linked list in-place.",
// 		text: undefined,
// 		code2: "```cpp<br>struct ListNode {<br>  int val;<br>  ListNode *next;<br>  ListNode() : val(0), next(nullptr) {}<br>  ListNode(int x) : val(x), next(nullptr) {}<br>  ListNode(int x, ListNode *next) : val(x), next(next) {}<br>};<br><br>ListNode* reverseList(ListNode* head) {<br>  // Implement the logic here<br>}<br>```",
// 		choices: [
// 			"1. `return head;`",
// 			"2. `return nullptr;`",
// 			"3. `return head->next;`",
// 			"4. `ListNode* prev = nullptr, *curr = head, *next = nullptr;`<br>  `while (curr) {`<br>  `next = curr->next;`<br>  `curr->next = prev;`<br>  `prev = curr;`<br>  `curr = next;`<br>  `}`<br>  `return prev;`",
// 		],
// 		answer: "4. `ListNode* prev = nullptr, *curr = head, *next = nullptr;`<br>  `while (curr) {`<br>  `next = curr->next;`<br>  `curr->next = prev;`<br>  `prev = curr;`<br>  `curr = next;`<br>  `}`<br>  `return prev;`",
// 		solution:
// 			"The code iterates through the linked list, reversing the pointers one node at a time. It uses three pointers: `prev`, `curr`, and `next`. `prev` points to the previously reversed portion of the list, initially `nullptr`. `curr` points to the current node being processed. `next` points to the node after the current node. The loop continues until `curr` reaches the end of the list. In each iteration, the `next` pointer is stored to preserve the original linked list structure. The `curr` node's `next` pointer is then set to `prev`, effectively reversing the pointer direction. The `prev` pointer is updated to `curr` to track the reversed portion, and the `curr` pointer is moved to `next` to process the next node in the list.  Finally, the `prev` pointer, which now points to the head of the reversed list, is returned.",
// 	},
// 	{
// 		id: 94,
// 		title: "# Q94. Find the middle node of a linked list.",
// 		text: undefined,
// 		code2: "```cpp<br>struct ListNode {<br>  int val;<br>  ListNode *next;<br>  ListNode() : val(0), next(nullptr) {}<br>  ListNode(int x) : val(x), next(nullptr) {}<br>  ListNode(int x, ListNode *next) : val(x), next(next) {}<br>};<br><br>ListNode* middleNode(ListNode* head) {<br>  // Implement the logic here<br>}<br>```",
// 		choices: [
// 			"1. `return head;`",
// 			"2. `return head->next;`",
// 			"3. `return nullptr;`",
// 			"4. `ListNode* slow = head, *fast = head;`<br>  `while (fast && fast->next) {`<br>  `slow = slow->next;`<br>  `fast = fast->next->next;`<br>  `}`<br>  `return slow;`",
// 		],
// 		answer: "4. `ListNode* slow = head, *fast = head;`<br>  `while (fast && fast->next) {`<br>  `slow = slow->next;`<br>  `fast = fast->next->next;`<br>  `}`<br>  `return slow;`",
// 		solution:
// 			"The code uses two pointers, `slow` and `fast`. `slow` moves one node at a time, while `fast` moves two nodes at a time.  When `fast` reaches the end of the list, `slow` will be pointing to the middle node.  If the list has an even number of nodes, `slow` will be pointing to the first of the two middle nodes.  This solution works because `fast` traverses the list twice as fast as `slow`, ensuring that when `fast` reaches the end, `slow` will have traversed half the list.",
// 	},
// 	{
// 		id: 95,
// 		title: "# Q95. Given an array of integers, find the two numbers that add up to a given target.",
// 		text: undefined,
// 		code2: "```cpp<br>vector<int> twoSum(vector<int>& nums, int target) {<br>  // Implement the logic here<br>}<br>```",
// 		choices: [
// 			"1. `return {};`",
// 			"2. `return {0, 1};`",
// 			"3. `unordered_map<int, int> map;`<br>  `for (int i = 0; i < nums.size(); ++i) {`<br>  `int complement = target - nums[i];`<br>  `if (map.count(complement)) {`<br>  `return {map[complement], i};`<br>  `}`<br>  `map[nums[i]] = i;`<br>  `}`<br>  `return {};`",
// 			"4. `for (int i = 0; i < nums.size(); ++i) {`<br>  `for (int j = i + 1; j < nums.size(); ++j) {`<br>  `if (nums[i] + nums[j] == target) {`<br>  `return {i, j};`<br>  `}`<br>  `}`<br>  `}`<br>  `return {};`",
// 		],
// 		answer: "3. `unordered_map<int, int> map;`<br>  `for (int i = 0; i < nums.size(); ++i) {`<br>  `int complement = target - nums[i];`<br>  `if (map.count(complement)) {`<br>  `return {map[complement], i};`<br>  `}`<br>  `map[nums[i]] = i;`<br>  `}`<br>  `return {};`",
// 		solution:
// 			"The code uses an `unordered_map` to store the numbers encountered in the array and their corresponding indices. It iterates through the array and calculates the complement for each number (the number that would add up to the target).  If the complement is found in the map, it means we have found the two numbers that add up to the target, and we return their indices.  Otherwise, we add the current number and its index to the map.  If no such pair is found, an empty vector is returned.",
// 	},
// 	{
// 		id: 96,
// 		title: "# Q96. Given a binary tree, check if it is a valid binary search tree.",
// 		text: undefined,
// 		code2: "```cpp<br>struct TreeNode {<br>  int val;<br>  TreeNode *left;<br>  TreeNode *right;<br>  TreeNode() : val(0), left(nullptr), right(nullptr) {}<br>  TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}<br>  TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}<br>};<br><br>bool isValidBST(TreeNode* root) {<br>  // Implement the logic here<br>}<br>```",
// 		choices: [
// 			"1. `return true;`",
// 			"2. `return false;`",
// 			"3. `return root == nullptr;`",
// 			"4. `return helper(root, nullptr, nullptr);`<br>  `bool helper(TreeNode* node, TreeNode* min, TreeNode* max) {`<br>  `if (node == nullptr) {`<br>  `return true;`<br>  `}`<br>  `if (min != nullptr && node->val <= min->val) {`<br>  `return false;`<br>  `}`<br>  `if (max != nullptr && node->val >= max->val) {`<br>  `return false;`<br>  `}`<br>  `return helper(node->left, min, node) && helper(node->right, node, max);`<br>  `}`",
// 		],
// 		answer: "4. `return helper(root, nullptr, nullptr);`<br>  `bool helper(TreeNode* node, TreeNode* min, TreeNode* max) {`<br>  `if (node == nullptr) {`<br>  `return true;`<br>  `}`<br>  `if (min != nullptr && node->val <= min->val) {`<br>  `return false;`<br>  `}`<br>  `if (max != nullptr && node->val >= max->val) {`<br>  `return false;`<br>  `}`<br>  `return helper(node->left, min, node) && helper(node->right, node, max);`<br>  `}`",
// 		solution:
// 			"The code utilizes a helper function `helper` to recursively check the validity of the binary search tree. The function takes a node, a minimum value, and a maximum value as arguments.  It checks if the node is `nullptr`, returning `true` if it is. It then checks if the node's value is within the specified range (greater than the `min` value and less than the `max` value). If not, it returns `false`.  Otherwise, it recursively checks the left subtree with the current node as the new `max` value and the right subtree with the current node as the new `min` value.  If both subtrees are valid binary search trees, the function returns `true`.  The `isValidBST` function simply calls the `helper` function with the root node and `nullptr` for both the minimum and maximum values, as the root node has no constraints.",
// 	},
// 	{
// 		id: 97,
// 		title: "# Q97. Given a string, check if it is a palindrome.",
// 		text: undefined,
// 		code2: "```cpp<br>bool isPalindrome(string s) {<br>  // Implement the logic here<br>}<br>```",
// 		choices: [
// 			"1. `return true;`",
// 			"2. `return false;`",
// 			"3. `return s == string(s.rbegin(), s.rend());`",
// 			"4. `int left = 0, right = s.size() - 1;`<br>  `while (left < right) {`<br>  `if (s[left] != s[right]) {`<br>  `return false;`<br>  `}`<br>  `left++;`<br>  `right--;`<br>  `}`<br>  `return true;`",
// 		],
// 		answer: "3. `return s == string(s.rbegin(), s.rend());`",
// 		solution:
// 			"This code utilizes the fact that reversing a palindrome results in the same string.  It creates a new string by reversing the original string and compares them.  If the two strings are equal, the original string is a palindrome and the function returns `true`.  Otherwise, it returns `false`.",
// 	},
// 	{
// 		id: 98,
// 		title: "# Q98. Given a string, find the length of the longest substring without repeating characters.",
// 		text: undefined,
// 		code2: "```cpp<br>int lengthOfLongestSubstring(string s) {<br>  // Implement the logic here<br>}<br>```",
// 		choices: [
// 			"1. `return 0;`",
// 			"2. `return s.size();`",
// 			"3. `int maxLength = 0;`<br>  `for (int i = 0; i < s.size(); ++i) {`<br>  `for (int j = i + 1; j <= s.size(); ++j) {`<br>  `if (isUnique(s, i, j)) {`<br>  `maxLength = max(maxLength, j - i);`<br>  `}`<br>  `}`<br>  `}`<br>  `return maxLength;`<br>  `bool isUnique(string s, int start, int end) {`<br>  `unordered_set<char> seen;`<br>  `for (int i = start; i < end; ++i) {`<br>  `if (seen.count(s[i])) {`<br>  `return false;`<br>  `}`<br>  `seen.insert(s[i]);`<br>  `}`<br>  `return true;`<br>  `}`",
// 			"4. `int maxLength = 0;`<br>  `unordered_set<char> seen;`<br>  `int left = 0;`<br>  `for (int right = 0; right < s.size(); ++right) {`<br>  `while (seen.count(s[right])) {`<br>  `seen.erase(s[left]);`<br>  `left++;`<br>  `}`<br>  `seen.insert(s[right]);`<br>  `maxLength = max(maxLength, right - left + 1);`<br>  `}`<br>  `return maxLength;`",
// 		],
// 		answer: "4. `int maxLength = 0;`<br>  `unordered_set<char> seen;`<br>  `int left = 0;`<br>  `for (int right = 0; right < s.size(); ++right) {`<br>  `while (seen.count(s[right])) {`<br>  `seen.erase(s[left]);`<br>  `left++;`<br>  `}`<br>  `seen.insert(s[right]);`<br>  `maxLength = max(maxLength, right - left + 1);`<br>  `}`<br>  `return maxLength;`",
// 		solution:
// 			"The code uses a sliding window approach with two pointers, `left` and `right`. `left` points to the beginning of the current substring, and `right` points to the end.  It uses an `unordered_set` to keep track of the characters seen in the current substring.  The loop iterates through the string using the `right` pointer.  For each character, it checks if it is already present in the `seen` set.  If it is, it means there's a repeating character.  In this case, it removes the character at `left` from the `seen` set and moves `left` to the right until the repeating character is removed.  Then, it adds the current character to the `seen` set and updates `maxLength` to the maximum length of the current substring.  This process continues until the end of the string is reached.  Finally, `maxLength` is returned, representing the length of the longest substring without repeating characters.",
// 	},
// 	// {
// 	// 	id: 99,
// 	// 	title: "# Q99. Given a string, check if it is a valid parentheses string.",
// 	// 	text: undefined,
// 	// 	code2: "```cpp<br>bool isValidParentheses(string s) {<br>  // Implement the logic here<br>}<br>```",
// 	// 	choices: [
// 	// 		"1. `return true;`",
// 	// 		"2. `return false;`",
// 	// 		"3. `stack<char> st;`<br>  `for (char c : s) {`<br>  `if (c == '(' || c == '{' || c == '[') {`<br>  `st.push(c);`<br>  `}` else if (c == ')' && !st.empty() && st.top() == '(') {`<br>  `st.pop();`<br>  `} else if (c == '}' && !st.empty() && st.top() == '{') {`<br>  `st.pop();`<br>  `} else if (c == ']' && !st.empty() && st.top() == '[') {`<br>  `st.pop();`<br>  `} else {`<br>  `return false;`<br>  `}`<br>  `}`<br>  `return st.empty();`",
// 	// 		"4. `if (s.size() % 2 != 0) {`<br>  `return false;`<br>  `}`<br>  `for (int i = 0; i < s.size() / 2; ++i) {`<br>  `if (s[i] != s[s.size() - i - 1]) {`<br>  `return false;`<br>  `}`<br>  `}`<br>  `return true;`",
// 	// 	],
// 	// 	answer: "3. `stack<char> st;`<br>  `for (char c : s) {`<br>  `if (c == '(' || c == '{' || c == '[') {`<br>  `st.push(c);`<br>  `}` else if (c == ')' && !st.empty() && st.top() == '(') {`<br>  `st.pop();`<br>  `} else if (c == '}' && !st.empty() && st.top() == '{') {`<br>  `st.pop();`<br>  `} else if (c == ']' && !st.empty() && st.top() == '[') {`<br>  `st.pop();`<br>  `} else {`<br>  `return false;`<br>  `}`<br>  `}`<br>  `return st.empty();`",
// 	// 	solution:
// 	// 		"The code uses a stack to keep track of the opening parentheses encountered. It iterates through the string character by character.  If an opening parenthesis is encountered, it is pushed onto the stack.  If a closing parenthesis is encountered, the code checks if the stack is not empty and if the top element of the stack is the corresponding opening parenthesis. If so, the opening parenthesis is popped from the stack.  If not, or if the stack is empty, the function returns `false`.  After processing all the characters, if the stack is empty, it means all parentheses are matched, and the function returns `true`.  Otherwise, it means there are unmatched parentheses, and the function returns `false`.",
// 	// },
// 	{
// 		id: 100,
// 		title: "# Q100. Given a sorted array, remove duplicates in-place.",
// 		text: undefined,
// 		code2: "```cpp<br>int removeDuplicates(vector<int>& nums) {<br>  // Implement the logic here<br>}<br>```",
// 		choices: [
// 			"1. `return 0;`",
// 			"2. `return nums.size();`",
// 			"3. `if (nums.empty()) {`<br>  `return 0;`<br>  `}`<br>  `int j = 0;`<br>  `for (int i = 1; i < nums.size(); ++i) {`<br>  `if (nums[i] != nums[j]) {`<br>  `j++;`<br>  `nums[j] = nums[i];`<br>  `}`<br>  `}`<br>  `return j + 1;`",
// 			"4. `sort(nums.begin(), nums.end());`<br>  `return nums.size();`",
// 		],
// 		answer: "3. `if (nums.empty()) {`<br>  `return 0;`<br>  `}`<br>  `int j = 0;`<br>  `for (int i = 1; i < nums.size(); ++i) {`<br>  `if (nums[i] != nums[j]) {`<br>  `j++;`<br>  `nums[j] = nums[i];`<br>  `}`<br>  `}`<br>  `return j + 1;`",
// 		solution:
// 			"The code iterates through the array using two pointers, `i` and `j`. `j` is used to track the position of the next unique element in the array.  The loop starts at `i = 1` to compare each element with the previous element at `j`.  If the current element is different from the previous element, it means it is a unique element.  In this case, we increment `j` and copy the current element to the position pointed to by `j`.  After the loop, `j + 1` represents the number of unique elements in the array.",
// 	},
// 	{
// 		id: 101,
// 		title: "# Q101. Implement the `maxDepth` function for a binary tree.",
// 		text: undefined,
// 		code2: "```cpp<br>struct TreeNode {<br>  int val;<br>  TreeNode *left;<br>  TreeNode *right;<br>  TreeNode() : val(0), left(nullptr), right(nullptr) {}<br>  TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}<br>  TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}<br>};<br><br>int maxDepth(TreeNode* root) {<br>  // Implement the logic here<br>}<br>```",
// 		choices: [
// 			"1. `return 0;`",
// 			"2. `return 1;`",
// 			"3. `if (root == nullptr) {`<br>  `return 0;`<br>  `}`<br>  `return max(maxDepth(root->left), maxDepth(root->right)) + 1;`",
// 			"4. `if (root == nullptr) {`<br>  `return 1;`<br>  `}`<br>  `return max(maxDepth(root->left), maxDepth(root->right));`",
// 		],
// 		answer: "3. `if (root == nullptr) {`<br>  `return 0;`<br>  `}`<br>  `return max(maxDepth(root->left), maxDepth(root->right)) + 1;`",
// 		solution:
// 			"The code utilizes a recursive approach to calculate the maximum depth of the binary tree.  If the `root` is `nullptr`, it means the tree is empty, and the depth is 0.  Otherwise, it recursively calculates the maximum depths of the left and right subtrees.  The maximum depth of the tree is then calculated by taking the maximum of the left and right subtree depths and adding 1 to account for the current node.  The final depth is then returned.",
// 	},
// 	{
// 		id: 102,
// 		title: "# Q102. Given a string, find the first non-repeating character.",
// 		text: undefined,
// 		code2: "```cpp<br>char firstNonRepeatingChar(string s) {<br>  // Implement the logic here<br>}<br>```",
// 		choices: [
// 			"1. `return ' ';`",
// 			"2. `return s[0];`",
// 			"3. `unordered_map<char, int> charCount;`<br>  `for (char c : s) {`<br>  `charCount[c]++;`<br>  `}`<br>  `for (char c : s) {`<br>  `if (charCount[c] == 1) {`<br>  `return c;`<br>  `}`<br>  `}`<br>  `return ' ';`",
// 			"4. `for (int i = 0; i < s.size(); ++i) {`<br>  `if (s.find(s[i]) == s.rfind(s[i])) {`<br>  `return s[i];`<br>  `}`<br>  `}`<br>  `return ' ';`",
// 		],
// 		answer: "3. `unordered_map<char, int> charCount;`<br>  `for (char c : s) {`<br>  `charCount[c]++;`<br>  `}`<br>  `for (char c : s) {`<br>  `if (charCount[c] == 1) {`<br>  `return c;`<br>  `}`<br>  `}`<br>  `return ' ';`",
// 		solution:
// 			"The code uses an `unordered_map` to count the occurrences of each character in the string.  It then iterates through the string again, and for each character, it checks if its count is 1 (meaning it appears only once).  If so, it returns that character.  If no non-repeating character is found, it returns a space.",
// 	},
// 	{
// 		id: 103,
// 		title: "# Q103. Given a sorted array and a target value, find the index of the target value if it exists, otherwise return -1.",
// 		text: undefined,
// 		code2: "```cpp<br>int search(vector<int>& nums, int target) {<br>  // Implement the logic here<br>}<br>```",
// 		choices: [
// 			"1. `return -1;`",
// 			"2. `return 0;`",
// 			"3. `return nums.size() - 1;`",
// 			"4. `int left = 0, right = nums.size() - 1;`<br>  `while (left <= right) {`<br>  `int mid = left + (right - left) / 2;`<br>  `if (nums[mid] == target) {`<br>  `return mid;`<br>  `}` else if (nums[mid] < target) {`<br>  `left = mid + 1;`<br>  `} else {`<br>  `right = mid - 1;`<br>  `}`<br>  `}`<br>  `return -1;`",
// 		],
// 		answer: "4. `int left = 0, right = nums.size() - 1;`<br>  `while (left <= right) {`<br>  `int mid = left + (right - left) / 2;`<br>  `if (nums[mid] == target) {`<br>  `return mid;`<br>  `}` else if (nums[mid] < target) {`<br>  `left = mid + 1;`<br>  `} else {`<br>  `right = mid - 1;`<br>  `}`<br>  `}`<br>  `return -1;`",
// 		solution:
// 			"The code implements binary search, which is a highly efficient algorithm for searching in a sorted array. It starts by initializing two pointers, `left` and `right`, to the beginning and end of the array, respectively.  The `while` loop continues as long as `left` is less than or equal to `right`. In each iteration, the `mid` pointer is calculated as the middle index of the remaining search range.  The target value is then compared with the value at the `mid` index.  If they are equal, the index `mid` is returned.  If the value at `mid` is less than the target, the `left` pointer is moved to `mid + 1`, indicating that the target value (if present) is in the right half of the search range.  Otherwise, the `right` pointer is moved to `mid - 1`, indicating that the target value (if present) is in the left half of the search range.  If the loop completes without finding the target value, the function returns -1.",
// 	},
// 	{
// 		id: 104,
// 		title: "# Q104. Given a sorted array, find the peak element (an element that is greater than its neighbors).",
// 		text: undefined,
// 		code2: "```cpp<br>int findPeakElement(vector<int>& nums) {<br>  // Implement the logic here<br>}<br>```",
// 		choices: [
// 			"1. `return 0;`",
// 			"2. `return nums.size() - 1;`",
// 			"3. `int left = 0, right = nums.size() - 1;`<br>  `while (left < right) {`<br>  `int mid = left + (right - left) / 2;`<br>  `if (nums[mid] < nums[mid + 1]) {`<br>  `left = mid + 1;`<br>  `} else {`<br>  `right = mid;`<br>  `}`<br>  `}`<br>  `return left;`",
// 			"4. `for (int i = 1; i < nums.size() - 1; ++i) {`<br>  `if (nums[i] > nums[i - 1] && nums[i] > nums[i + 1]) {`<br>  `return i;`<br>  `}`<br>  `}`<br>  `return 0;`",
// 		],
// 		answer: "3. `int left = 0, right = nums.size() - 1;`<br>  `while (left < right) {`<br>  `int mid = left + (right - left) / 2;`<br>  `if (nums[mid] < nums[mid + 1]) {`<br>  `left = mid + 1;`<br>  `} else {`<br>  `right = mid;`<br>  `}`<br>  `}`<br>  `return left;`",
// 		solution:
// 			"The code implements a binary search approach to find the peak element. It initializes two pointers, `left` and `right`, to the beginning and end of the array, respectively.  The `while` loop continues as long as `left` is less than `right`.  In each iteration, the `mid` pointer is calculated as the middle index of the remaining search range. The code then compares the value at `mid` with the value at `mid + 1`.  If the value at `mid` is less than the value at `mid + 1`, it means the peak element is in the right half of the search range, so the `left` pointer is moved to `mid + 1`.  Otherwise, the peak element is in the left half of the search range, and the `right` pointer is moved to `mid`.  After the loop, the `left` pointer will be pointing to the peak element.",
// 	},
// 	{
// 		id: 105,
// 		title: "# Q105. Given a string, check if it is a valid anagram of another string.",
// 		text: undefined,
// 		code2: "```cpp<br>bool isAnagram(string s, string t) {<br>  // Implement the logic here<br>}<br>```",
// 		choices: [
// 			"1. `return true;`",
// 			"2. `return false;`",
// 			"3. `if (s.size() != t.size()) {`<br>  `return false;`<br>  `}`<br>  `sort(s.begin(), s.end());`<br>  `sort(t.begin(), t.end());`<br>  `return s == t;`",
// 			"4. `unordered_map<char, int> charCount;`<br>  `for (char c : s) {`<br>  `charCount[c]++;`<br>  `}`<br>  `for (char c : t) {`<br>  `if (--charCount[c] < 0) {`<br>  `return false;`<br>  `}`<br>  `}`<br>  `return true;`",
// 		],
// 		answer: "4. `unordered_map<char, int> charCount;`<br>  `for (char c : s) {`<br>  `charCount[c]++;`<br>  `}`<br>  `for (char c : t) {`<br>  `if (--charCount[c] < 0) {`<br>  `return false;`<br>  `}`<br>  `}`<br>  `return true;`",
// 		solution:
// 			"The code uses an `unordered_map` to count the occurrences of each character in the first string `s`.  It then iterates through the second string `t`.  For each character in `t`, it decrements its count in the map.  If the count becomes negative, it means the character appears more times in `t` than in `s`, so the function returns `false`.  If the loop completes without finding any negative counts, it means all characters in `t` are present in `s` with the same frequency, and the function returns `true`.",
// 	},

// 	{
// 		id: 107,
// 		title: "# Q107. What is the primary use case for a hash table?",
// 		text: undefined,
// 		code2: "  ",
// 		choices: [
// 			"1. Sorting data in ascending order",
// 			"2. Implementing a stack data structure",
// 			"3. Efficiently storing and retrieving data based on keys",
// 			"4. Representing hierarchical relationships between elements",
// 		],
// 		answer: "3. Efficiently storing and retrieving data based on keys",
// 		solution:
// 			"Hash tables excel at providing fast access to data by using a hash function to map keys to specific locations in the table. This allows for near constant-time (O(1)) lookups, insertions, and deletions on average, making them ideal for scenarios where rapid data retrieval is crucial.",
// 	},
// 	{
// 		id: 108,
// 		title: "# Q108. Which data structure is best suited for implementing a Last-In, First-Out (LIFO) behavior?",
// 		text: undefined,
// 		code2: "  ",
// 		choices: ["1. Queue", "2. Stack", "3. Heap", "4. Tree"],
// 		answer: "2. Stack",
// 		solution:
// 			"Stacks are designed to operate on a LIFO principle, where the last element added is the first one to be removed.  Think of a stack of plates – you always take the top plate off first.",
// 	},
// 	{
// 		id: 109,
// 		title: "# Q109. What is the time complexity of inserting an element into a binary search tree?",
// 		text: undefined,
// 		code2: "  ",
// 		choices: ["1. O(n)", "2. O(log n)", "3. O(1)", "4. O(n log n)"],
// 		answer: "2. O(log n)",
// 		solution:
// 			"On average, inserting into a balanced binary search tree takes logarithmic time. This is because the tree's structure allows for efficient partitioning and traversal to find the correct insertion point. In the worst case, if the tree becomes unbalanced, insertion could take linear time.",
// 	},
// 	{
// 		id: 110,
// 		title: "# Q110. What is the purpose of a priority queue?",
// 		text: undefined,
// 		code2: "  ",
// 		choices: [
// 			"1. Storing elements in a specific order based on their priority",
// 			"2. Implementing a stack data structure",
// 			"3. Sorting data in ascending order",
// 			"4. Representing hierarchical relationships between elements",
// 		],
// 		answer: "1. Storing elements in a specific order based on their priority",
// 		solution:
// 			"A priority queue prioritizes elements based on a defined ordering. It allows for efficient retrieval of the highest (or lowest) priority element, making it ideal for tasks like scheduling, resource allocation, and handling events in a specific order.",
// 	},
// 	{
// 		id: 111,
// 		title: "# Q111. What is the advantage of using a heap over a simple array for implementing a priority queue?",
// 		text: undefined,
// 		code2: "  ",
// 		choices: [
// 			"1. Heaps offer constant-time access to the element with the highest priority.",
// 			"2. Heaps allow for more efficient insertion and deletion operations while maintaining the priority order.",
// 			"3. Heaps are easier to implement than arrays.",
// 			"4. Heaps use less memory than arrays.",
// 		],
// 		answer: "2. Heaps allow for more efficient insertion and deletion operations while maintaining the priority order.",
// 		solution:
// 			"While a simple array could technically store priority queue elements, heaps provide the advantage of efficient insertion and deletion operations that maintain the priority order. This is due to the heap's property of always keeping the highest (or lowest) priority element at the root.",
// 	},
// 	{
// 		id: 112,
// 		title: "# Q112. What is the main difference between a binary search tree and a heap?",
// 		text: undefined,
// 		code2: "  ",
// 		choices: [
// 			"1. Binary search trees store elements in sorted order, while heaps store elements based on their priority.",
// 			"2. Binary search trees allow for efficient searching, while heaps allow for efficient insertion and deletion.",
// 			"3. Binary search trees are implemented using arrays, while heaps are implemented using linked lists.",
// 			"4. Binary search trees are used for sorting, while heaps are used for scheduling.",
// 		],
// 		answer: "1. Binary search trees store elements in sorted order, while heaps store elements based on their priority.",
// 		solution:
// 			"Binary search trees maintain a sorted order based on the values of the nodes, allowing for efficient searching. Heaps, on the other hand, prioritize elements based on a defined order (typically min-heap or max-heap), making them suitable for scenarios where priority is the primary factor.",
// 	},
// 	{
// 		id: 113,
// 		title: "# Q113. What is the time complexity of sorting an array using bubble sort in the best-case scenario?",
// 		text: undefined,
// 		code2: "  ",
// 		choices: ["1. O(n)", "2. O(n log n)", "3. O(n^2)", "4. O(1)"],
// 		answer: "1. O(n)",
// 		solution:
// 			"In the best-case scenario, when the array is already sorted, bubble sort will only need to iterate through the array once to verify its sorted state. This results in a time complexity of O(n).",
// 	},
// 	// {
// 	// 	id: 114,
// 	// 	title: "# Q114. What is the time complexity of searching for a specific element in a sorted array using binary search?",
// 	// 	text: undefined,
// 	// 	code2: "  ",
// 	// 	choices: ["1. O(n)", "2. O(log n)", "3. O(1)", "4. O(n^2)"],
// 	// 	answer: "2. O(log n)",
// 	// 	solution:
// 	// 		"Binary search efficiently searches a sorted array by repeatedly dividing the search space in half. This logarithmic time complexity makes it significantly faster than linear search, especially for large datasets.",
// 	// },
// 	{
// 		id: 115,
// 		title: "# Q115. Which of the following is a common application of a trie (prefix tree)?",
// 		text: undefined,
// 		code2: "  ",
// 		choices: [
// 			"1. Implementing a stack data structure",
// 			"2. Sorting data in ascending order",
// 			"3. Autocomplete suggestions in a search bar",
// 			"4. Finding the shortest path in a graph",
// 		],
// 		answer: "3. Autocomplete suggestions in a search bar",
// 		solution:
// 			"Tries are specifically designed for efficient prefix-based search, making them a suitable choice for autocomplete functionalities. They allow for quick retrieval of words or suggestions based on the prefix entered by the user.",
// 	},
// 	{
// 		id: 116,
// 		title: "# Q116. What is the main advantage of using a linked list over an array for implementing a queue?",
// 		text: undefined,
// 		code2: "  ",
// 		choices: [
// 			"1. Linked lists offer constant-time insertion and deletion at the front of the queue.",
// 			"2. Linked lists are easier to implement than arrays.",
// 			"3. Linked lists use less memory than arrays.",
// 			"4. Linked lists allow for faster random access to elements.",
// 		],
// 		answer: "1. Linked lists offer constant-time insertion and deletion at the front of the queue.",
// 		solution:
// 			"When implementing a queue using a linked list, insertions and deletions at the front (enqueue and dequeue) can be performed in constant time. This is because only pointer manipulation is required, unlike arrays where shifting elements might be necessary.",
// 	},
// 	{
// 		id: 117,
// 		title: "# Q117. What is the primary use case for a graph data structure?",
// 		text: undefined,
// 		code2: "  ",
// 		choices: [
// 			"1. Representing hierarchical relationships between elements",
// 			"2. Modeling interconnected networks and relationships",
// 			"3. Sorting data in ascending order",
// 			"4. Implementing a stack data structure",
// 		],
// 		answer: "2. Modeling interconnected networks and relationships",
// 		solution:
// 			"Graphs are ideal for representing networks and relationships between entities.  They allow for modeling connections, dependencies, flow, and interactions, making them valuable in fields like social networks, transportation systems, network routing, and more.",
// 	},
// 	{
// 		id: 118,
// 		title: "# Q118. What is the time complexity of finding the minimum element in a min-heap?",
// 		text: undefined,
// 		code2: "  ",
// 		choices: ["1. O(n)", "2. O(log n)", "3. O(1)", "4. O(n log n)"],
// 		answer: "3. O(1)",
// 		solution:
// 			"In a min-heap, the minimum element is always stored at the root.  Therefore, accessing it directly takes constant time.",
// 	},
// 	{
// 		id: 119,
// 		title: "# Q119. Which of the following is NOT a common sorting algorithm?",
// 		text: undefined,
// 		code2: "  ",
// 		choices: [
// 			"1. Merge Sort",
// 			"2. Quick Sort",
// 			"3. Insertion Sort",
// 			"4. Binary Search",
// 		],
// 		answer: "4. Binary Search",
// 		solution:
// 			"Binary Search is a search algorithm designed for finding a specific element within a sorted array.  Sorting algorithms like Merge Sort, Quick Sort, and Insertion Sort arrange elements in a specific order.",
// 	},
// 	{
// 		id: 120,
// 		title: "# Q120. What is the primary difference between a directed graph and an undirected graph?",
// 		text: undefined,
// 		code2: "  ",
// 		choices: [
// 			"1. Directed graphs have edges with a specific direction, while undirected graphs do not.",
// 			"2. Undirected graphs have edges with a specific direction, while directed graphs do not.",
// 			"3. Directed graphs are used to represent hierarchies, while undirected graphs are used to represent networks.",
// 			"4. Undirected graphs are used to represent hierarchies, while directed graphs are used to represent networks.",
// 		],
// 		answer: "1. Directed graphs have edges with a specific direction, while undirected graphs do not.",
// 		solution:
// 			"In a directed graph, edges represent one-way connections (e.g., a road network with one-way streets), while undirected graphs represent two-way connections (e.g., a social network where individuals can be friends with each other).",
// 	},
// 	{
// 		id: 121,
// 		title: "# Q121. What is the purpose of a disjoint set data structure?",
// 		text: undefined,
// 		code2: "  ",
// 		choices: [
// 			"1. Storing elements in a specific order based on their priority",
// 			"2. Representing a collection of sets where each element belongs to exactly one set",
// 			"3. Implementing a stack data structure",
// 			"4. Sorting data in ascending order",
// 		],
// 		answer: "2. Representing a collection of sets where each element belongs to exactly one set",
// 		solution:
// 			"Disjoint sets, or union-find data structures, are used to manage a collection of sets where each element belongs to only one set.  They are particularly useful for handling connectivity and grouping problems.",
// 	},
// 	{
// 		id: 122,
// 		title: "# Q122. Which data structure is often used to implement a priority queue?",
// 		text: undefined,
// 		code2: "  ",
// 		choices: ["1. Linked List", "2. Array", "3. Heap", "4. Stack"],
// 		answer: "3. Heap",
// 		solution:
// 			"Heaps are commonly used for implementing priority queues. Their efficient insertion, deletion, and retrieval of the highest (or lowest) priority element make them suitable for prioritizing operations.",
// 	},
// 	{
// 		id: 123,
// 		title: "# Q123. What is the time complexity of finding the kth smallest element in a sorted array?",
// 		text: undefined,
// 		code2: "  ",
// 		choices: ["1. O(n)", "2. O(1)", "3. O(log n)", "4. O(n log n)"],
// 		answer: "2. O(1)",
// 		solution:
// 			"Since the array is already sorted, accessing the kth smallest element directly by indexing takes constant time.",
// 	},
// 	{
// 		id: 124,
// 		title: "# Q124. What is the primary difference between a stack and a queue in terms of data access?",
// 		text: undefined,
// 		code2: "  ",
// 		choices: [
// 			"1. Stacks are LIFO (Last-In, First-Out), queues are FIFO (First-In, First-Out)",
// 			"2. Stacks are FIFO, queues are LIFO",
// 			"3. Stacks use arrays, queues use linked lists",
// 			"4. Stacks use linked lists, queues use arrays",
// 		],
// 		answer: "1. Stacks are LIFO (Last-In, First-Out), queues are FIFO (First-In, First-Out)",
// 		solution:
// 			"Stacks follow a LIFO order, meaning the last element added is the first to be removed.  Queues operate on a FIFO principle, where the first element added is the first to be removed.",
// 	},
// 	{
// 		id: 125,
// 		title: "# Q125. What is the time complexity of deleting an element from the front of a queue implemented using a linked list?",
// 		text: undefined,
// 		code2: "  ",
// 		choices: ["1. O(n)", "2. O(1)", "3. O(log n)", "4. O(n log n)"],
// 		answer: "2. O(1)",
// 		solution:
// 			"Deleting an element from the front of a queue implemented using a linked list involves simply adjusting the head pointer, which takes constant time.",
// 	},
// 	{
// 		id: 126,
// 		title: "# Q126. What is the time complexity of inserting an element at the end of a queue implemented using an array?",
// 		text: undefined,
// 		code2: "  ",
// 		choices: ["1. O(n)", "2. O(1)", "3. O(log n)", "4. O(n log n)"],
// 		answer: "1. O(n)",
// 		solution:
// 			"Inserting at the end of an array-based queue may require shifting elements to make space for the new element, leading to linear time complexity.",
// 	},
// 	{
// 		id: 127,
// 		title: "# Q127. Which of the following is a common use case for a heap data structure?",
// 		text: undefined,
// 		code2: "  ",
// 		choices: [
// 			"1. Implementing a stack data structure",
// 			"2. Sorting data in ascending order",
// 			"3. Efficiently storing and retrieving data based on keys",
// 			"4. Scheduling tasks based on their priority",
// 		],
// 		answer: "4. Scheduling tasks based on their priority",
// 		solution:
// 			"Heaps are widely used for scheduling tasks based on their priority. Their efficient retrieval of the highest (or lowest) priority element makes them suitable for prioritizing tasks.",
// 	},
// 	{
// 		id: 128,
// 		title: "# Q128. What is the time complexity of finding the maximum element in a heap?",
// 		text: undefined,
// 		code2: "  ",
// 		choices: ["1. O(n)", "2. O(log n)", "3. O(1)", "4. O(n log n)"],
// 		answer: "3. O(1)",
// 		solution:
// 			"The maximum (or minimum) element in a heap is always located at the root, making it directly accessible in constant time.",
// 	},
// 	// {
// 	// 	id: 129,
// 	// 	title: "# Q129. What is the time complexity of deleting an element from the end of a linked list?",
// 	// 	text: undefined,
// 	// 	code2: "  ",
// 	// 	choices: ["1. O(n)", "2. O(1)", "3. O(log n)", "4. O(n log n)"],
// 	// 	answer: "1. O(n)",
// 	// 	solution:
// 	// 		"Deleting an element from the end of a linked list requires iterating through the list until the second-to-last node is reached, leading to linear time complexity.",
// 	// },
// 	{
// 		id: 130,
// 		title: "# Q130. Which of the following is NOT a valid binary tree traversal method?",
// 		text: undefined,
// 		code2: "  ",
// 		choices: [
// 			"1. Preorder Traversal",
// 			"2. Inorder Traversal",
// 			"3. Postorder Traversal",
// 			"4. Random Traversal",
// 		],
// 		answer: "4. Random Traversal",
// 		solution:
// 			"While various traversal strategies exist, 'Random Traversal' is not a standardized or commonly used method.  Binary tree traversal methods are typically structured for specific orderings of node visitation.",
// 	},
// 	{
// 		id: 131,
// 		title: "# Q131. What is the time complexity of finding the depth of a binary tree?",
// 		text: undefined,
// 		code2: "  ",
// 		choices: ["1. O(n)", "2. O(log n)", "3. O(1)", "4. O(n log n)"],
// 		answer: "1. O(n)",
// 		solution:
// 			"Finding the depth of a binary tree requires visiting all nodes in the worst case, resulting in linear time complexity.",
// 	},
// 	{
// 		id: 132,
// 		title: "# Q132. Which of the following is a common application of a graph data structure?",
// 		text: undefined,
// 		code2: "  ",
// 		choices: [
// 			"1. Implementing a stack data structure",
// 			"2. Sorting data in ascending order",
// 			"3. Modeling social networks",
// 			"4. Efficiently storing and retrieving data based on keys",
// 		],
// 		answer: "3. Modeling social networks",
// 		solution:
// 			"Graphs are ideal for representing complex relationships between entities, making them suitable for modeling social networks, where connections and interactions between users are crucial.",
// 	},
// 	{
// 		id: 133,
// 		title: "# Q133. What is the time complexity of inserting an element at the beginning of a linked list?",
// 		text: undefined,
// 		code2: "  ",
// 		choices: ["1. O(n)", "2. O(1)", "3. O(log n)", "4. O(n log n)"],
// 		answer: "2. O(1)",
// 		solution:
// 			"Inserting at the beginning of a linked list involves adjusting the head pointer and making the new node point to the original head, which takes constant time.",
// 	},
// 	{
// 		id: 134,
// 		title: "# Q134. What is the primary use case for a stack data structure?",
// 		text: undefined,
// 		code2: "  ",
// 		choices: [
// 			"1. Implementing a queue data structure",
// 			"2. Sorting data in ascending order",
// 			"3. Handling function calls in a program",
// 			"4. Efficiently storing and retrieving data based on keys",
// 		],
// 		answer: "3. Handling function calls in a program",
// 		solution:
// 			"Stacks are essential for managing function calls in programs. They keep track of the order in which functions are called and ensure that they are returned in the reverse order.",
// 	},
// 	{
// 		id: 135,
// 		title: "# Q135. What is the time complexity of searching for an element in a binary search tree in the best-case scenario?",
// 		text: undefined,
// 		code2: "  ",
// 		choices: ["1. O(n)", "2. O(log n)", "3. O(1)", "4. O(n log n)"],
// 		answer: "3. O(1)",
// 		solution:
// 			"In the best case, when the target element is the root of the tree, it can be found in constant time.",
// 	},
// 	{
// 		id: 136,
// 		title: "# Q136. Which of the following is a common sorting algorithm with an average time complexity of O(n log n)?",
// 		text: undefined,
// 		code2: "  ",
// 		choices: [
// 			"1. Bubble Sort",
// 			"2. Insertion Sort",
// 			"3. Merge Sort",
// 			"4. Selection Sort",
// 		],
// 		answer: "3. Merge Sort",
// 		solution:
// 			"Merge Sort consistently maintains an average time complexity of O(n log n), making it a reliable choice for large datasets.",
// 	},
// 	// {
// 	// 	id: 137,
// 	// 	title: "# Q137. What is the purpose of a self-balancing binary search tree?",
// 	// 	text: undefined,
// 	// 	code2: "  ",
// 	// 	choices: [
// 	// 		"1. To ensure that the tree is always balanced, even after insertions and deletions",
// 	// 		"2. To improve the efficiency of search operations",
// 	// 		"3. To prevent the tree from becoming too skewed",
// 	// 		"4. All of the above",
// 	// 	],
// 	// 	answer: "4. All of the above",
// 	// 	solution:
// 	// 		"Self-balancing binary search trees are designed to maintain a balanced structure to prevent worst-case scenarios, resulting in efficient search, insertion, and deletion operations.",
// 	// },
// 	{
// 		id: 138,
// 		title: "# Q138. What is the time complexity of deleting an element from a heap?",
// 		text: undefined,
// 		code2: "  ",
// 		choices: ["1. O(n)", "2. O(log n)", "3. O(1)", "4. O(n log n)"],
// 		answer: "2. O(log n)",
// 		solution:
// 			"Deleting an element from a heap involves maintaining the heap property by rearranging the elements, resulting in logarithmic time complexity.",
// 	},
// 	{
// 		id: 139,
// 		title: "# Q139. What is the time complexity of searching for an element in a hash table in the worst-case scenario?",
// 		text: undefined,
// 		code2: "  ",
// 		choices: ["1. O(n)", "2. O(1)", "3. O(log n)", "4. O(n log n)"],
// 		answer: "1. O(n)",
// 		solution:
// 			"In the worst-case scenario, when all elements hash to the same location, searching in a hash table degenerates to a linear search, taking linear time.",
// 	},
// 	{
// 		id: 140,
// 		title: "# Q140. Which of the following is NOT a common dynamic programming problem?",
// 		text: undefined,
// 		code2: "  ",
// 		choices: [
// 			"1. Fibonacci sequence",
// 			"2. Knapsack problem",
// 			"3. Traveling salesman problem",
// 			"4. Quick Sort",
// 		],
// 		answer: "4. Quick Sort",
// 		solution:
// 			"Quick Sort is a divide-and-conquer algorithm, not a dynamic programming algorithm.  Dynamic programming relies on storing and reusing previously calculated results.",
// 	},
// 	{
// 		id: 141,
// 		title: "# Q141. What is the main advantage of using a linked list over an array for implementing a stack?",
// 		text: undefined,
// 		code2: "  ",
// 		choices: [
// 			"1. Linked lists offer constant-time insertion and deletion at the top of the stack.",
// 			"2. Linked lists are easier to implement than arrays.",
// 			"3. Linked lists use less memory than arrays.",
// 			"4. Linked lists allow for faster random access to elements.",
// 		],
// 		answer: "1. Linked lists offer constant-time insertion and deletion at the top of the stack.",
// 		solution:
// 			"Linked lists allow for fast insertion and deletion at the top of the stack because they only involve adjusting pointers, avoiding the need to shift elements like in arrays.",
// 	},
// 	{
// 		id: 142,
// 		title: "# Q142. What is the purpose of a breadth-first search (BFS) algorithm?",
// 		text: undefined,
// 		code2: "  ",
// 		choices: [
// 			"1. To find the shortest path between two nodes in an unweighted graph",
// 			"2. To sort elements in alphabetical order",
// 			"3. To find the maximum element in a graph",
// 			"4. To delete an element from a graph",
// 		],
// 		answer: "1. To find the shortest path between two nodes in an unweighted graph",
// 		solution:
// 			"BFS explores a graph level by level, making it ideal for finding the shortest path in unweighted graphs.  It systematically explores all neighbors at a current level before moving to the next level.",
// 	},
// 	// {
// 	// 	id: 143,
// 	// 	title: "# Q143. What is the time complexity of sorting an array using insertion sort in the best-case scenario?",
// 	// 	text: undefined,
// 	// 	code2: "  ",
// 	// 	choices: ["1. O(n)", "2. O(n log n)", "3. O(n^2)", "4. O(1)"],
// 	// 	answer: "1. O(n)",
// 	// 	solution:
// 	// 		"In the best-case scenario, when the array is already sorted, insertion sort will only need to iterate through the array once, making its time complexity linear.",
// 	// },
// 	{
// 		id: 144,
// 		title: "# Q144. Which of the following is NOT a common application of a trie (prefix tree)?",
// 		text: undefined,
// 		code2: "  ",
// 		choices: [
// 			"1. Autocomplete suggestions in a search bar",
// 			"2. Spell checking",
// 			"3. Implementing a queue data structure",
// 			"4. Dictionary implementations",
// 		],
// 		answer: "3. Implementing a queue data structure",
// 		solution:
// 			"Tries are optimized for string-based operations like prefix search and are not directly related to queue implementations.",
// 	},
// 	{
// 		id: 145,
// 		title: "# Q145. What is the time complexity of finding the mode of an unsorted array?",
// 		text: undefined,
// 		code2: "  ",
// 		choices: ["1. O(n)", "2. O(1)", "3. O(log n)", "4. O(n log n)"],
// 		answer: "1. O(n)",
// 		solution:
// 			"Finding the mode of an unsorted array requires scanning all elements to determine the most frequently occurring element, resulting in linear time complexity.",
// 	},
// 	{
// 		id: 146,
// 		title: "# Q146. Which of the following is a common self-balancing binary search tree?",
// 		text: undefined,
// 		code2: "  ",
// 		choices: ["1. AVL Tree", "2. B-Tree", "3. Heap", "4. Trie"],
// 		answer: "1. AVL Tree",
// 		solution:
// 			"AVL Trees are a type of self-balancing binary search tree that ensure a balanced structure to maintain efficient search operations.",
// 	},
// 	{
// 		id: 147,
// 		title: "# Q147. What is the purpose of a depth-first search (DFS) algorithm?",
// 		text: undefined,
// 		code2: "  ",
// 		choices: [
// 			"1. To find the shortest path between two nodes in an unweighted graph",
// 			"2. To find all reachable nodes from a given source node",
// 			"3. To sort elements in alphabetical order",
// 			"4. To delete an element from a graph",
// 		],
// 		answer: "2. To find all reachable nodes from a given source node",
// 		solution:
// 			"DFS explores a graph by going as deep as possible along each branch before backtracking, making it effective for finding all reachable nodes from a source node.",
// 	},
// 	{
// 		id: 148,
// 		title: "# Q148. What is the time complexity of sorting an array using selection sort?",
// 		text: undefined,
// 		code2: "  ",
// 		choices: ["1. O(n)", "2. O(n log n)", "3. O(n^2)", "4. O(1)"],
// 		answer: "3. O(n^2)",
// 		solution:
// 			"Selection Sort has a time complexity of O(n^2), as it repeatedly scans the array to find the minimum (or maximum) element and places it in the correct position.",
// 	},
// 	{
// 		id: 149,
// 		title: "# Q149. What is the primary use case for a queue data structure?",
// 		text: undefined,
// 		code2: "  ",
// 		choices: [
// 			"1. Implementing a stack data structure",
// 			"2. Sorting data in ascending order",
// 			"3. Handling function calls in a program",
// 			"4. Processing items in a first-come, first-served order",
// 		],
// 		answer: "4. Processing items in a first-come, first-served order",
// 		solution:
// 			"Queues are designed for processing items in a FIFO order, making them suitable for scenarios like managing print jobs, handling requests in a service queue, or simulating real-world queueing systems.",
// 	},
// 	{
// 		id: 150,
// 		title: "# Q150. What is the time complexity of inserting an element into a heap?",
// 		text: undefined,
// 		code2: "  ",
// 		choices: ["1. O(n)", "2. O(log n)", "3. O(1)", "4. O(n log n)"],
// 		answer: "2. O(log n)",
// 		solution:
// 			"Inserting an element into a heap involves maintaining the heap property, which requires rearranging elements, resulting in logarithmic time complexity.",
// 	},
// 	{
// 		id: 151,
// 		title: "# Q151. Which data structure is best suited for implementing a First-In, First-Out (FIFO) behavior?",
// 		text: undefined,
// 		code2: "  ",
// 		choices: ["1. Stack", "2. Queue", "3. Heap", "4. Tree"],
// 		answer: "2. Queue",
// 		solution:
// 			"Queues are specifically designed to operate on a FIFO principle, where the first element added is the first to be removed.",
// 	},
// 	{
// 		id: 152,
// 		title: "# Q152. What is the time complexity of finding the range of a sorted array?",
// 		text: undefined,
// 		code2: "  ",
// 		choices: ["1. O(n)", "2. O(1)", "3. O(log n)", "4. O(n log n)"],
// 		answer: "2. O(1)",
// 		solution:
// 			"Finding the range of a sorted array involves accessing the first and last elements, which takes constant time.",
// 	},
// 	{
// 		id: 153,
// 		title: "# Q153. Which of the following is a common application of a dynamic programming algorithm?",
// 		text: undefined,
// 		code2: "  ",
// 		choices: [
// 			"1. Implementing a stack data structure",
// 			"2. Sorting data in ascending order",
// 			"3. Finding the shortest path in a weighted graph",
// 			"4. Efficiently storing and retrieving data based on keys",
// 		],
// 		answer: "3. Finding the shortest path in a weighted graph",
// 		solution:
// 			"Dynamic programming algorithms excel at solving problems by breaking them down into smaller subproblems and reusing previously computed solutions.  This makes them suitable for problems like finding the shortest path in a graph, where subpaths can be reused.",
// 	},
// 	{
// 		id: 154,
// 		title: "# Q154. What is the time complexity of deleting an element from the top of a stack implemented using a linked list?",
// 		text: undefined,
// 		code2: "  ",
// 		choices: ["1. O(n)", "2. O(1)", "3. O(log n)", "4. O(n log n)"],
// 		answer: "2. O(1)",
// 		solution:
// 			"Deleting an element from the top of a linked list-based stack involves adjusting the top pointer, which takes constant time.",
// 	},
// ];

// let dsa3 = [
// 	{
// 		id: 166,
// 		title: "# Q166. Given a binary tree, find its maximum depth.",
// 		text: undefined,
// 		code2: "```cpp<br>struct TreeNode {<br>  int val;<br>  TreeNode *left;<br>  TreeNode *right;<br>  TreeNode() : val(0), left(nullptr), right(nullptr) {}<br>  TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}<br>  TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}<br>};<br><br>int maxDepth(TreeNode* root) {<br>  // Implement the logic here<br>}<br>```",
// 		choices: [
// 			"1. `return 0;`",
// 			"2. `return 1;`",
// 			"3. `if (root == nullptr) {`<br>  `return 0;`<br>  `}`<br>  `return max(maxDepth(root->left), maxDepth(root->right)) + 1;`",
// 			"4. `if (root == nullptr) {`<br>  `return 1;`<br>  `}`<br>  `return max(maxDepth(root->left), maxDepth(root->right));`",
// 		],
// 		answer: "3. `if (root == nullptr) {`<br>  `return 0;`<br>  `}`<br>  `return max(maxDepth(root->left), maxDepth(root->right)) + 1;`",
// 		solution:
// 			"```cpp<br>int maxDepth(TreeNode* root) {<br>  if (root == nullptr) {<br>    return 0;<br>  }<br>  return max(maxDepth(root->left), maxDepth(root->right)) + 1;<br>}<br>```<br><br>This code calculates the maximum depth of a binary tree recursively. If the root is `nullptr`, it means the tree is empty, and the depth is 0. Otherwise, it recursively calculates the maximum depths of the left and right subtrees.  The maximum depth of the tree is then calculated by taking the maximum of the left and right subtree depths and adding 1 to account for the current node.  The final depth is then returned.",
// 	},
// 	{
// 		id: 167,
// 		title: "# Q167. Given a string, find the length of the longest substring without repeating characters.",
// 		text: undefined,
// 		code2: "```cpp<br>int lengthOfLongestSubstring(string s) {<br>  // Implement the logic here<br>}<br>```",
// 		choices: [
// 			"1. `return 0;`",
// 			"2. `return s.size();`",
// 			"3. `int maxLength = 0;`<br>  `for (int i = 0; i < s.size(); ++i) {`<br>  `for (int j = i + 1; j <= s.size(); ++j) {`<br>  `if (isUnique(s, i, j)) {`<br>  `maxLength = max(maxLength, j - i);`<br>  `}`<br>  `}`<br>  `}`<br>  `return maxLength;`<br>  `bool isUnique(string s, int start, int end) {`<br>  `unordered_set<char> seen;`<br>  `for (int i = start; i < end; ++i) {`<br>  `if (seen.count(s[i])) {`<br>  `return false;`<br>  `}`<br>  `seen.insert(s[i]);`<br>  `}`<br>  `return true;`<br>  `}`",
// 			"4. `int maxLength = 0;`<br>  `unordered_set<char> seen;`<br>  `int left = 0;`<br>  `for (int right = 0; right < s.size(); ++right) {`<br>  `while (seen.count(s[right])) {`<br>  `seen.erase(s[left]);`<br>  `left++;`<br>  `}`<br>  `seen.insert(s[right]);`<br>  `maxLength = max(maxLength, right - left + 1);`<br>  `}`<br>  `return maxLength;`",
// 		],
// 		answer: "4. `int maxLength = 0;`<br>  `unordered_set<char> seen;`<br>  `int left = 0;`<br>  `for (int right = 0; right < s.size(); ++right) {`<br>  `while (seen.count(s[right])) {`<br>  `seen.erase(s[left]);`<br>  `left++;`<br>  `}`<br>  `seen.insert(s[right]);`<br>  `maxLength = max(maxLength, right - left + 1);`<br>  `}`<br>  `return maxLength;`",
// 		solution:
// 			"```cpp<br>int lengthOfLongestSubstring(string s) {<br>  int maxLength = 0;<br>  unordered_set<char> seen;<br>  int left = 0;<br>  for (int right = 0; right < s.size(); ++right) {<br>    while (seen.count(s[right])) {<br>      seen.erase(s[left]);<br>      left++;<br>    }<br>    seen.insert(s[right]);<br>    maxLength = max(maxLength, right - left + 1);<br>  }<br>  return maxLength;<br>}<br>```<br><br>This code uses a sliding window approach with two pointers, `left` and `right`. `left` points to the beginning of the current substring, and `right` points to the end.  It uses an `unordered_set` to keep track of the characters seen in the current substring.  The loop iterates through the string using the `right` pointer.  For each character, it checks if it is already present in the `seen` set.  If it is, it means there's a repeating character.  In this case, it removes the character at `left` from the `seen` set and moves `left` to the right until the repeating character is removed.  Then, it adds the current character to the `seen` set and updates `maxLength` to the maximum length of the current substring.  This process continues until the end of the string is reached.  Finally, `maxLength` is returned, representing the length of the longest substring without repeating characters.",
// 	},
// 	{
// 		id: 168,
// 		title: "# Q168. Given a string, check if it is a valid parentheses string.",
// 		text: undefined,
// 		code2: "```cpp<br>bool isValidParentheses(string s) {<br>  // Implement the logic here<br>}<br>```",
// 		choices: [
// 			"1. `return true;`",
// 			"2. `return false;`",
// 			"3. `stack<char> st;`<br>  `for (char c : s) {`<br>  `if (c == '(' || c == '{' || c == '[') {`<br>  `st.push(c);`<br>  `}` else if (c == ')' && !st.empty() && st.top() == '(') {`<br>  `st.pop();`<br>  `} else if (c == '}' && !st.empty() && st.top() == '{') {`<br>  `st.pop();`<br>  `} else if (c == ']' && !st.empty() && st.top() == '[') {`<br>  `st.pop();`<br>  `} else {`<br>  `return false;`<br>  `}`<br>  `}`<br>  `return st.empty();`",
// 			"4. `if (s.size() % 2 != 0) {`<br>  `return false;`<br>  `}`<br>  `for (int i = 0; i < s.size() / 2; ++i) {`<br>  `if (s[i] != s[s.size() - i - 1]) {`<br>  `return false;`<br>  `}`<br>  `}`<br>  `return true;`",
// 		],
// 		answer: "3. `stack<char> st;`<br>  `for (char c : s) {`<br>  `if (c == '(' || c == '{' || c == '[') {`<br>  `st.push(c);`<br>  `}` else if (c == ')' && !st.empty() && st.top() == '(') {`<br>  `st.pop();`<br>  `} else if (c == '}' && !st.empty() && st.top() == '{') {`<br>  `st.pop();`<br>  `} else if (c == ']' && !st.empty() && st.top() == '[') {`<br>  `st.pop();`<br>  `} else {`<br>  `return false;`<br>  `}`<br>  `}`<br>  `return st.empty();`",
// 		solution:
// 			"```cpp<br>bool isValidParentheses(string s) {<br>  stack<char> st;<br>  for (char c : s) {<br>    if (c == '(' || c == '{' || c == '[') {<br>      st.push(c);<br>    } else if (c == ')' && !st.empty() && st.top() == '(') {<br>      st.pop();<br>    } else if (c == '}' && !st.empty() && st.top() == '{') {<br>      st.pop();<br>    } else if (c == ']' && !st.empty() && st.top() == '[') {<br>      st.pop();<br>    } else {<br>      return false;<br>    }<br>  }<br>  return st.empty();<br>}<br>```<br><br>This code uses a stack to keep track of the opening parentheses encountered. It iterates through the string character by character.  If an opening parenthesis is encountered, it is pushed onto the stack.  If a closing parenthesis is encountered, the code checks if the stack is not empty and if the top element of the stack is the corresponding opening parenthesis. If so, the opening parenthesis is popped from the stack.  If not, or if the stack is empty, the function returns `false`.  After processing all the characters, if the stack is empty, it means all parentheses are matched, and the function returns `true`.  Otherwise, it means there are unmatched parentheses, and the function returns `false`.",
// 	},
// 	{
// 		id: 169,
// 		title: "# Q169. Given a string, find the first unique character in the string.",
// 		text: undefined,
// 		code2: "```cpp<br>char firstUniqueChar(string s) {<br>  // Implement the logic here<br>}<br>```",
// 		choices: [
// 			"1. `return ' ';`",
// 			"2. `return s[0];`",
// 			"3. `unordered_map<char, int> charCount;`<br>  `for (char c : s) {`<br>  `charCount[c]++;`<br>  `}`<br>  `for (int i = 0; i < s.size(); ++i) {`<br>  `if (charCount[s[i]] == 1) {`<br>  `return s[i];`<br>  `}`<br>  `}`<br>  `return ' ';`",
// 			"4. `for (int i = 0; i < s.size(); ++i) {`<br>  `if (s.find(s[i]) == s.rfind(s[i])) {`<br>  `return s[i];`<br>  `}`<br>  `}`<br>  `return ' ';`",
// 		],
// 		answer: "3. `unordered_map<char, int> charCount;`<br>  `for (char c : s) {`<br>  `charCount[c]++;`<br>  `}`<br>  `for (int i = 0; i < s.size(); ++i) {`<br>  `if (charCount[s[i]] == 1) {`<br>  `return s[i];`<br>  `}`<br>  `}`<br>  `return ' ';`",
// 		solution:
// 			"```cpp<br>char firstUniqueChar(string s) {<br>  unordered_map<char, int> charCount;<br>  for (char c : s) {<br>    charCount[c]++;<br>  }<br>  for (int i = 0; i < s.size(); ++i) {<br>    if (charCount[s[i]] == 1) {<br>      return s[i];<br>    }<br>  }<br>  return ' ';<br>}<br>```<br><br>This code finds the first non-repeating character in a string. It uses an `unordered_map` to count the occurrences of each character in the string.  It then iterates through the string and checks if the count of the current character is 1. If so, it returns that character.  If no non-repeating character is found, it returns a space.",
// 	},
// 	{
// 		id: 170,
// 		title: "# Q170. Given an array of integers, find the two numbers that add up to a given target.",
// 		text: undefined,
// 		code2: "```cpp<br>vector<int> twoSum(vector<int>& nums, int target) {<br>  // Implement the logic here<br>}<br>```",
// 		choices: [
// 			"1. `return {};`",
// 			"2. `return {0, 1};`",
// 			"3. `unordered_map<int, int> map;`<br>  `for (int i = 0; i < nums.size(); ++i) {`<br>  `int complement = target - nums[i];`<br>  `if (map.count(complement)) {`<br>  `return {map[complement], i};`<br>  `}`<br>  `map[nums[i]] = i;`<br>  `}`<br>  `return {};`",
// 			"4. `for (int i = 0; i < nums.size(); ++i) {`<br>  `for (int j = i + 1; j < nums.size(); ++j) {`<br>  `if (nums[i] + nums[j] == target) {`<br>  `return {i, j};`<br>  `}`<br>  `}`<br>  `}`<br>  `return {};`",
// 		],
// 		answer: "3. `unordered_map<int, int> map;`<br>  `for (int i = 0; i < nums.size(); ++i) {`<br>  `int complement = target - nums[i];`<br>  `if (map.count(complement)) {`<br>  `return {map[complement], i};`<br>  `}`<br>  `map[nums[i]] = i;`<br>  `}`<br>  `return {};`",
// 		solution:
// 			"```cpp<br>vector<int> twoSum(vector<int>& nums, int target) {<br>  unordered_map<int, int> map;<br>  for (int i = 0; i < nums.size(); ++i) {<br>    int complement = target - nums[i];<br>    if (map.count(complement)) {<br>      return {map[complement], i};<br>    }<br>    map[nums[i]] = i;<br>  }<br>  return {};<br>}<br>```<br><br>This code finds the two numbers in an array that add up to a given target. It uses an `unordered_map` to store the numbers encountered in the array and their corresponding indices. It iterates through the array and calculates the complement for each number (the number that would add up to the target).  If the complement is found in the map, it means we have found the two numbers that add up to the target, and we return their indices.  Otherwise, we add the current number and its index to the map.  If no such pair is found, an empty vector is returned.",
// 	},
// 	{
// 		id: 171,
// 		title: "# Q171. Given an array of integers, find the maximum product of two numbers.",
// 		text: undefined,
// 		code2: "```cpp<br>int maxProduct(vector<int>& nums) {<br>  // Implement the logic here<br>}<br>```",
// 		choices: [
// 			"1. `return nums[0] * nums[1];`",
// 			"2. `return nums[nums.size() - 1] * nums[nums.size() - 2];`",
// 			"3. `sort(nums.begin(), nums.end());`<br>  `return nums[nums.size() - 1] * nums[nums.size() - 2];`",
// 			"4. `int max1 = INT_MIN, max2 = INT_MIN;`<br>  `for (int num : nums) {`<br>  `if (num > max1) {`<br>  `max2 = max1;`<br>  `max1 = num;`<br>  `} else if (num > max2) {`<br>  `max2 = num;`<br>  `}`<br>  `}`<br>  `return max1 * max2;`",
// 		],
// 		answer: "4. `int max1 = INT_MIN, max2 = INT_MIN;`<br>  `for (int num : nums) {`<br>  `if (num > max1) {`<br>  `max2 = max1;`<br>  `max1 = num;`<br>  `} else if (num > max2) {`<br>  `max2 = num;`<br>  `}`<br>  `}`<br>  `return max1 * max2;`",
// 		solution:
// 			"```cpp<br>int maxProduct(vector<int>& nums) {<br>  int max1 = INT_MIN, max2 = INT_MIN;<br>  for (int num : nums) {<br>    if (num > max1) {<br>      max2 = max1;<br>      max1 = num;<br>    } else if (num > max2) {<br>      max2 = num;<br>    }<br>  }<br>  return max1 * max2;<br>}<br>```<br><br>This code finds the maximum product of two numbers in an array.  It keeps track of the two largest numbers (`max1`, `max2`) in the array.  The code iterates through the array and updates these variables accordingly.  Finally, it returns the product of the two largest numbers (`max1 * max2`).  ",
// 	},

// 	{
// 		id: 173,
// 		title: "# Q173. Given an array of integers, find the sum of all even numbers in the array.",
// 		text: undefined,
// 		code2: "```cpp<br>int sumEvenNumbers(vector<int>& nums) {<br>  // Implement the logic here<br>}<br>```",
// 		choices: [
// 			"1. `return 0;`",
// 			"2. `return nums[0];`",
// 			"3. `int sum = 0;`<br>  `for (int i = 0; i < nums.size(); ++i) {`<br>  `if (nums[i] % 2 == 0) {`<br>  `sum += nums[i];`<br>  `}`<br>  `}`<br>  `return sum;`",
// 			"4. `return nums[nums.size() - 1];`",
// 		],
// 		answer: "3. `int sum = 0;`<br>  `for (int i = 0; i < nums.size(); ++i) {`<br>  `if (nums[i] % 2 == 0) {`<br>  `sum += nums[i];`<br>  `}`<br>  `}`<br>  `return sum;`",
// 		solution:
// 			"```cpp<br>int sumEvenNumbers(vector<int>& nums) {<br>  int sum = 0;<br>  for (int i = 0; i < nums.size(); ++i) {<br>    if (nums[i] % 2 == 0) {<br>      sum += nums[i];<br>    }<br>  }<br>  return sum;<br>}<br>```<br><br>This code finds the sum of all even numbers in an array.  It initializes a variable `sum` to 0.  It then iterates through the array and checks if each number is even using the modulo operator (`%`).  If the number is even, it is added to `sum`.  After iterating through the entire array, `sum` will contain the sum of all even numbers, which is then returned.",
// 	},
// 	{
// 		id: 174,
// 		title: "# Q174. Given an array of integers, find the product of all numbers in the array.",
// 		text: undefined,
// 		code2: "```cpp<br>int productOfNumbers(vector<int>& nums) {<br>  // Implement the logic here<br>}<br>```",
// 		choices: [
// 			"1. `return 0;`",
// 			"2. `return nums[0];`",
// 			"3. `int product = 1;`<br>  `for (int i = 0; i < nums.size(); ++i) {`<br>  `product *= nums[i];`<br>  `}`<br>  `return product;`",
// 			"4. `return nums[nums.size() - 1];`",
// 		],
// 		answer: "3. `int product = 1;`<br>  `for (int i = 0; i < nums.size(); ++i) {`<br>  `product *= nums[i];`<br>  `}`<br>  `return product;`",
// 		solution:
// 			"```cpp<br>int productOfNumbers(vector<int>& nums) {<br>  int product = 1;<br>  for (int i = 0; i < nums.size(); ++i) {<br>    product *= nums[i];<br>  }<br>  return product;<br>}<br>```<br><br>This code finds the product of all numbers in an array.  It initializes a variable `product` to 1.  It then iterates through the array and multiplies each number by `product`.  After iterating through the entire array, `product` will contain the product of all numbers, which is then returned.",
// 	},
// 	{
// 		id: 175,
// 		title: "# Q175. Given a string, find the number of vowels in the string.",
// 		text: undefined,
// 		code2: "```cpp<br>int countVowels(string s) {<br>  // Implement the logic here<br>}<br>```",
// 		choices: [
// 			"1. `return 0;`",
// 			"2. `return s.size();`",
// 			"3. `int count = 0;`<br>  `for (char c : s) {`<br>  `if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') {`<br>  `count++;`<br>  `}`<br>  `}`<br>  `return count;`",
// 			"4. `return s.length();`",
// 		],
// 		answer: "3. `int count = 0;`<br>  `for (char c : s) {`<br>  `if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') {`<br>  `count++;`<br>  `}`<br>  `}`<br>  `return count;`",
// 		solution:
// 			"```cpp<br>int countVowels(string s) {<br>  int count = 0;<br>  for (char c : s) {<br>    if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') {<br>      count++;<br>    }<br>  }<br>  return count;<br>}<br>```<br><br>This code counts the number of vowels in a string. It initializes a variable `count` to 0.  It then iterates through the string and checks if each character is a vowel.  If it is, it increments `count`.  After iterating through the entire string, `count` will contain the number of vowels, which is then returned.",
// 	},
// 	{
// 		id: 176,
// 		title: "# Q176. Given a string, find the number of consonants in the string.",
// 		text: undefined,
// 		code2: "```cpp<br>int countConsonants(string s) {<br>  // Implement the logic here<br>}<br>```",
// 		choices: [
// 			"1. `return 0;`",
// 			"2. `return s.size();`",
// 			"3. `int count = 0;`<br>  `for (char c : s) {`<br>  `if (isalpha(c) && !(c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u')) {`<br>  `count++;`<br>  `}`<br>  `}`<br>  `return count;`",
// 			"4. `return s.length();`",
// 		],
// 		answer: "3. `int count = 0;`<br>  `for (char c : s) {`<br>  `if (isalpha(c) && !(c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u')) {`<br>  `count++;`<br>  `}`<br>  `}`<br>  `return count;`",
// 		solution:
// 			"```cpp<br>int countConsonants(string s) {<br>  int count = 0;<br>  for (char c : s) {<br>    if (isalpha(c) && !(c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u')) {<br>      count++;<br>    }<br>  }<br>  return count;<br>}<br>```<br><br>This code counts the number of consonants in a string. It initializes a variable `count` to 0.  It then iterates through the string and checks if each character is a letter using `isalpha(c)` and if it is not a vowel.  If it is a consonant, it increments `count`.  After iterating through the entire string, `count` will contain the number of consonants, which is then returned.",
// 	},
// 	{
// 		id: 177,
// 		title: "# Q177. Given a string, check if it is a valid email address.",
// 		text: undefined,
// 		code2: "```cpp<br>bool isValidEmail(string email) {<br>  // Implement the logic here<br>}<br>```",
// 		choices: [
// 			"1. `return true;`",
// 			"2. `return false;`",
// 			'3. `regex pattern("^([a-zA-Z0-9_\\-\\.]+)@([a-zA-Z0-9\\-]+)\\.([a-zA-Z]{2,5})$^");`<br>  `return regex_match(email, pattern);`',
// 			"4. `if (email.find('@') == string::npos) {`<br>  `return false;`<br>  `}`<br>  `return true;`",
// 		],
// 		answer: '3. `regex pattern("^([a-zA-Z0-9_\\-\\.]+)@([a-zA-Z0-9\\-]+)\\.([a-zA-Z]{2,5})$^");`<br>  `return regex_match(email, pattern);`',
// 		solution:
// 			'```cpp<br>bool isValidEmail(string email) {<br>  regex pattern("^([a-zA-Z0-9_\\-\\.]+)@([a-zA-Z0-9\\-]+)\\.([a-zA-Z]{2,5})$^");<br>  return regex_match(email, pattern);<br>}<br>```<br><br>This code checks if a string is a valid email address using regular expressions. It defines a regular expression pattern that matches a typical email format (e.g., `username@domain.com`).  The `regex_match` function then compares the email string with the pattern. If the email matches the pattern, the function returns `true`.  Otherwise, it returns `false`.',
// 	},
// 	{
// 		id: 178,
// 		title: "# Q178. Given a string, find the number of words in the string.",
// 		text: undefined,
// 		code2: "```cpp<br>int countWords(string s) {<br>  // Implement the logic here<br>}<br>```",
// 		choices: [
// 			"1. `return 0;`",
// 			"2. `return s.size();`",
// 			"3. `int count = 1;`<br>  `for (char c : s) {`<br>  `if (c == ' ') {`<br>  `count++;`<br>  `}`<br>  `}`<br>  `return count;`",
// 			"4. `return s.length();`",
// 		],
// 		answer: "3. `int count = 1;`<br>  `for (char c : s) {`<br>  `if (c == ' ') {`<br>  `count++;`<br>  `}`<br>  `}`<br>  `return count;`",
// 		solution:
// 			"```cpp<br>int countWords(string s) {<br>  int count = 1;<br>  for (char c : s) {<br>    if (c == ' ') {<br>      count++;<br>    }<br>  }<br>  return count;<br>}<br>```<br><br>This code counts the number of words in a string.  It initializes a variable `count` to 1 (assuming there is at least one word).  It then iterates through the string and checks if each character is a space.  If it is, it increments `count`.  After iterating through the entire string, `count` will contain the number of words, which is then returned.",
// 	},

// 	{
// 		id: 179,
// 		title: "# Q179. Given an array of integers, find the length of the longest subarray with a sum equal to 0.",
// 		text: undefined,
// 		code2: "int longestZeroSumSubarray(vector<int>& nums) {  // Implement the logic here }",
// 		choices: [
// 			"1. return 0;",
// 			"2. return nums.size();",
// 			"3. unordered_map<int, int> prefixSumIndices; int sum = 0, maxLength = 0; for (int i = 0; i < nums.size(); i++) { sum += nums[i]; if (sum == 0) { maxLength = i + 1; } if (prefixSumIndices.find(sum) != prefixSumIndices.end()) { maxLength = max(maxLength, i - prefixSumIndices[sum]); } else { prefixSumIndices[sum] = i; } } return maxLength;",
// 			"4. return nums.length();",
// 		],
// 		answer: "3. unordered_map<int, int> prefixSumIndices; int sum = 0, maxLength = 0; for (int i = 0; i < nums.size(); i++) { sum += nums[i]; if (sum == 0) { maxLength = i + 1; } if (prefixSumIndices.find(sum) != prefixSumIndices.end()) { maxLength = max(maxLength, i - prefixSumIndices[sum]); } else { prefixSumIndices[sum] = i; } } return maxLength;",
// 		solution:
// 			"int longestZeroSumSubarray(vector<int>& nums) { unordered_map<int, int> prefixSumIndices; int sum = 0, maxLength = 0; for (int i = 0; i < nums.size(); i++) { sum += nums[i]; if (sum == 0) { maxLength = i + 1; } if (prefixSumIndices.find(sum) != prefixSumIndices.end()) { maxLength = max(maxLength, i - prefixSumIndices[sum]); } else { prefixSumIndices[sum] = i; } } return maxLength; }",
// 	},
// 	{
// 		id: 180,
// 		title: "# Q180. Given a binary tree, return the level order traversal of its nodes' values.",
// 		text: undefined,
// 		code2: "vector<vector<int>> levelOrder(TreeNode* root) {  // Implement the logic here }",
// 		choices: [
// 			"1. return {};",
// 			"2. return {{}};",
// 			"3. vector<vector<int>> result; if (!root) return result; queue<TreeNode*> q; q.push(root); while (!q.empty()) { int size = q.size(); vector<int> level; for (int i = 0; i < size; i++) { TreeNode* node = q.front(); q.pop(); level.push_back(node->val); if (node->left) q.push(node->left); if (node->right) q.push(node->right); } result.push_back(level); } return result;",
// 			"4. return root;",
// 		],
// 		answer: "3. vector<vector<int>> result; if (!root) return result; queue<TreeNode*> q; q.push(root); while (!q.empty()) { int size = q.size(); vector<int> level; for (int i = 0; i < size; i++) { TreeNode* node = q.front(); q.pop(); level.push_back(node->val); if (node->left) q.push(node->left); if (node->right) q.push(node->right); } result.push_back(level); } return result;",
// 		solution:
// 			"vector<vector<int>> levelOrder(TreeNode* root) { vector<vector<int>> result; if (!root) return result; queue<TreeNode*> q; q.push(root); while (!q.empty()) { int size = q.size(); vector<int> level; for (int i = 0; i < size; i++) { TreeNode* node = q.front(); q.pop(); level.push_back(node->val); if (node->left) q.push(node->left); if (node->right) q.push(node->right); } result.push_back(level); } return result; }",
// 	},
// 	{
// 		id: 181,
// 		title: "# Q181. Given a string, find the length of the longest substring without repeating characters.",
// 		text: undefined,
// 		code2: "int lengthOfLongestSubstring(string s) {  // Implement the logic here }",
// 		choices: [
// 			"1. return 0;",
// 			"2. return s.size();",
// 			"3. unordered_map<char, int> charIndex; int maxLength = 0, start = 0; for (int i = 0; i < s.size(); i++) { if (charIndex.find(s[i]) != charIndex.end() && charIndex[s[i]] >= start) { start = charIndex[s[i]] + 1; } charIndex[s[i]] = i; maxLength = max(maxLength, i - start + 1); } return maxLength;",
// 			"4. return s.length();",
// 		],
// 		answer: "3. unordered_map<char, int> charIndex; int maxLength = 0, start = 0; for (int i = 0; i < s.size(); i++) { if (charIndex.find(s[i]) != charIndex.end() && charIndex[s[i]] >= start) { start = charIndex[s[i]] + 1; } charIndex[s[i]] = i; maxLength = max(maxLength, i - start + 1); } return maxLength;",
// 		solution:
// 			"int lengthOfLongestSubstring(string s) { unordered_map<char, int> charIndex; int maxLength = 0, start = 0; for (int i = 0; i < s.size(); i++) { if (charIndex.find(s[i]) != charIndex.end() && charIndex[s[i]] >= start) { start = charIndex[s[i]] + 1; } charIndex[s[i]] = i; maxLength = max(maxLength, i - start + 1); } return maxLength; }",
// 	},
// 	{
// 		id: 182,
// 		title: "# Q182. Given an array of integers, return the maximum product of three numbers in the array.",
// 		text: undefined,
// 		code2: "int maximumProduct(vector<int>& nums) {  // Implement the logic here }",
// 		choices: [
// 			"1. return 0;",
// 			"2. return nums.size();",
// 			"3. sort(nums.begin(), nums.end()); int n = nums.size(); return max(nums[n-1] * nums[n-2] * nums[n-3], nums[0] * nums[1] * nums[n-1]);",
// 			"4. return nums.length();",
// 		],
// 		answer: "3. sort(nums.begin(), nums.end()); int n = nums.size(); return max(nums[n-1] * nums[n-2] * nums[n-3], nums[0] * nums[1] * nums[n-1]);",
// 		solution:
// 			"int maximumProduct(vector<int>& nums) { sort(nums.begin(), nums.end()); int n = nums.size(); return max(nums[n-1] * nums[n-2] * nums[n-3], nums[0] * nums[1] * nums[n-1]); }",
// 	},
// 	{
// 		id: 183,
// 		title: "# Q183. Given a string, return the longest palindromic substring.",
// 		text: undefined,
// 		code2: "string longestPalindrome(string s) {  // Implement the logic here }",
// 		choices: [
// 			"1. return '';",
// 			"2. return s;",
// 			"3. int n = s.size(); if (n == 0) return ''; vector<vector<bool>> dp(n, vector<bool>(n, false)); int maxLength = 1, start = 0; for (int i = 0; i < n; i++) { dp[i][i] = true; } for (int i = 0; i < n - 1; i++) { if (s[i] == s[i + 1]) { dp[i][i + 1] = true; start = i; maxLength = 2; } } for (int k = 3; k <= n; k++) { for (int i = 0; i < n - k + 1; i++) { int j = i + k - 1; if (dp[i + 1][j - 1] && s[i] == s[j]) { dp[i][j] = true; if (k > maxLength) { start = i; maxLength = k; } } } } return s.substr(start, maxLength);",
// 			"4. return s.length();",
// 		],
// 		answer: "3. int n = s.size(); if (n == 0) return ''; vector<vector<bool>> dp(n, vector<bool>(n, false)); int maxLength = 1, start = 0; for (int i = 0; i < n; i++) { dp[i][i] = true; } for (int i = 0; i < n - 1; i++) { if (s[i] == s[i + 1]) { dp[i][i + 1] = true; start = i; maxLength = 2; } } for (int k = 3; k <= n; k++) { for (int i = 0; i < n - k + 1; i++) { int j = i + k - 1; if (dp[i + 1][j - 1] && s[i] == s[j]) { dp[i][j] = true; if (k > maxLength) { start = i; maxLength = k; } } } } return s.substr(start, maxLength);",
// 		solution:
// 			"string longestPalindrome(string s) { int n = s.size(); if (n == 0) return ''; vector<vector<bool>> dp(n, vector<bool>(n, false)); int maxLength = 1, start = 0; for (int i = 0; i < n; i++) { dp[i][i] = true; } for (int i = 0; i < n - 1; i++) { if (s[i] == s[i + 1]) { dp[i][i + 1] = true; start = i; maxLength = 2; } } for (int k = 3; k <= n; k++) { for (int i = 0; i < n - k + 1; i++) { int j = i + k - 1; if (dp[i + 1][j - 1] && s[i] == s[j]) { dp[i][j] = true; if (k > maxLength) { start = i; maxLength = k; } } } } return s.substr(start, maxLength); }",
// 	},
// 	{
// 		id: 184,
// 		title: "# Q184. Given an array of integers, return the maximum sum of a subarray.",
// 		text: undefined,
// 		code2: "int maxSubArray(vector<int>& nums) {  // Implement the logic here }",
// 		choices: [
// 			"1. return 0;",
// 			"2. return nums.size();",
// 			"3. int maxSum = nums[0], currentSum = nums[0]; for (int i = 1; i < nums.size(); i++) { currentSum = max(nums[i], currentSum + nums[i]); maxSum = max(maxSum, currentSum); } return maxSum;",
// 			"4. return nums.length();",
// 		],
// 		answer: "3. int maxSum = nums[0], currentSum = nums[0]; for (int i = 1; i < nums.size(); i++) { currentSum = max(nums[i], currentSum + nums[i]); maxSum = max(maxSum, currentSum); } return maxSum;",
// 		solution:
// 			"int maxSubArray(vector<int>& nums) { int maxSum = nums[0], currentSum = nums[0]; for (int i = 1; i < nums.size(); i++) { currentSum = max(nums[i], currentSum + nums[i]); maxSum = max(maxSum, currentSum); } return maxSum; }",
// 	},
// 	{
// 		id: 185,
// 		title: "# Q185. Given a binary tree, return the maximum depth of the tree.",
// 		text: undefined,
// 		code2: "int maxDepth(TreeNode* root) {  // Implement the logic here }",
// 		choices: [
// 			"1. return 0;",
// 			"2. return root;",
// 			"3. if (!root) return 0; return 1 + max(maxDepth(root->left), maxDepth(root->right));",
// 			"4. return root->val;",
// 		],
// 		answer: "3. if (!root) return 0; return 1 + max(maxDepth(root->left), maxDepth(root->right));",
// 		solution:
// 			"int maxDepth(TreeNode* root) { if (!root) return 0; return 1 + max(maxDepth(root->left), maxDepth(root->right)); }",
// 	},
// 	{
// 		id: 186,
// 		title: "# Q186. Given a binary tree, return the minimum depth of the tree.",
// 		text: undefined,
// 		code2: "int minDepth(TreeNode* root) {  // Implement the logic here }",
// 		choices: [
// 			"1. return 0;",
// 			"2. return root;",
// 			"3. if (!root) return 0; if (!root->left) return 1 + minDepth(root->right); if (!root->right) return 1 + minDepth(root->left); return 1 + min(minDepth(root->left), minDepth(root->right));",
// 			"4. return root->val;",
// 		],
// 		answer: "3. if (!root) return 0; if (!root->left) return 1 + minDepth(root->right); if (!root->right) return 1 + minDepth(root->left); return 1 + min(minDepth(root->left), minDepth(root->right));",
// 		solution:
// 			"int minDepth(TreeNode* root) { if (!root) return 0; if (!root->left) return 1 + minDepth(root->right); if (!root->right) return 1 + minDepth(root->left); return 1 + min(minDepth(root->left), minDepth(root->right)); }",
// 	},
// 	{
// 		id: 187,
// 		title: "# Q187. Given a string, find the first non-repeating character.",
// 		text: undefined,
// 		code2: "char firstNonRepeatingCharacter(string s) {  // Implement the logic here }",
// 		choices: [
// 			"1. return ' ';",
// 			"2. return s[0];",
// 			"3. unordered_map<char, int> charCount; for (char c : s) { charCount[c]++; } for (char c : s) { if (charCount[c] == 1) { return c; } } return ' ';",
// 			"4. return s.length();",
// 		],
// 		answer: "3. unordered_map<char, int> charCount; for (char c : s) { charCount[c]++; } for (char c : s) { if (charCount[c] == 1) { return c; } } return ' ';",
// 		solution:
// 			"char firstNonRepeatingCharacter(string s) { unordered_map<char, int> charCount; for (char c : s) { charCount[c]++; } for (char c : s) { if (charCount[c] == 1) { return c; } } return ' '; }",
// 	},
// 	{
// 		id: 188,
// 		title: "# Q188. Given an array of integers, return the second largest element.",
// 		text: undefined,
// 		code2: "int secondLargestElement(vector<int>& nums) {  // Implement the logic here }",
// 		choices: [
// 			"1. return 0;",
// 			"2. return nums.size();",
// 			"3. int first = INT_MIN, second = INT_MIN; for (int num : nums) { if (num > first) { second = first; first = num; } else if (num > second && num != first) { second = num; } } return second;",
// 			"4. return nums.length();",
// 		],
// 		answer: "3. int first = INT_MIN, second = INT_MIN; for (int num : nums) { if (num > first) { second = first; first = num; } else if (num > second && num != first) { second = num; } } return second;",
// 		solution:
// 			"int secondLargestElement(vector<int>& nums) { int first = INT_MIN, second = INT_MIN; for (int num : nums) { if (num > first) { second = first; first = num; } else if (num > second && num != first) { second = num; } } return second; }",
// 	},
// 	{
// 		id: 189,
// 		title: "# Q189. Given a string, return the most frequent character.",
// 		text: undefined,
// 		code2: "char mostFrequentCharacter(string s) {  // Implement the logic here }",
// 		choices: [
// 			"1. return ' ';",
// 			"2. return s[0];",
// 			"3. unordered_map<char, int> charCount; char mostFrequent = ' '; int maxCount = 0; for (char c : s) { charCount[c]++; if (charCount[c] > maxCount) { maxCount = charCount[c]; mostFrequent = c; } } return mostFrequent;",
// 			"4. return s.length();",
// 		],
// 		answer: "3. unordered_map<char, int> charCount; char mostFrequent = ' '; int maxCount = 0; for (char c : s) { charCount[c]++; if (charCount[c] > maxCount) { maxCount = charCount[c]; mostFrequent = c; } } return mostFrequent;",
// 		solution:
// 			"char mostFrequentCharacter(string s) { unordered_map<char, int> charCount; char mostFrequent = ' '; int maxCount = 0; for (char c : s) { charCount[c]++; if (charCount[c] > maxCount) { maxCount = charCount[c]; mostFrequent = c; } } return mostFrequent; }",
// 	},
// 	{
// 		id: 190,
// 		title: "# Q190. Given an array of integers, return the number of unique elements.",
// 		text: undefined,
// 		code2: "int countUniqueElements(vector<int>& nums) {  // Implement the logic here }",
// 		choices: [
// 			"1. return 0;",
// 			"2. return nums.size();",
// 			"3. unordered_set<int> uniqueElements; for (int num : nums) { uniqueElements.insert(num); } return uniqueElements.size();",
// 			"4. return nums.length();",
// 		],
// 		answer: "3. unordered_set<int> uniqueElements; for (int num : nums) { uniqueElements.insert(num); } return uniqueElements.size();",
// 		solution:
// 			"int countUniqueElements(vector<int>& nums) { unordered_set<int> uniqueElements; for (int num : nums) { uniqueElements.insert(num); } return uniqueElements.size(); }",
// 	},
// 	{
// 		id: 191,
// 		title: "# Q191. Given a string, return the number of vowels in the string.",
// 		text: undefined,
// 		code2: "int countVowels(string s) {  // Implement the logic here }",
// 		choices: [
// 			"1. return 0;",
// 			"2. return s.size();",
// 			"3. int count = 0; for (char c : s) { if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') { count++; } } return count;",
// 			"4. return s.length();",
// 		],
// 		answer: "3. int count = 0; for (char c : s) { if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') { count++; } } return count;",
// 		solution:
// 			"int countVowels(string s) { int count = 0; for (char c : s) { if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') { count++; } } return count; }",
// 	},
// 	{
// 		id: 192,
// 		title: "# Q192. Given an array of integers, return the sum of all even numbers.",
// 		text: undefined,
// 		code2: "int sumEvenNumbers(vector<int>& nums) {  // Implement the logic here }",
// 		choices: [
// 			"1. return 0;",
// 			"2. return nums.size();",
// 			"3. int sum = 0; for (int num : nums) { if (num % 2 == 0) { sum += num; } } return sum;",
// 			"4. return nums.length();",
// 		],
// 		answer: "3. int sum = 0; for (int num : nums) { if (num % 2 == 0) { sum += num; } } return sum;",
// 		solution:
// 			"int sumEvenNumbers(vector<int>& nums) { int sum = 0; for (int num : nums) { if (num % 2 == 0) { sum += num; } } return sum; }",
// 	},
// 	{
// 		id: 193,
// 		title: "# Q193. Given a string, return the number of consonants in the string.",
// 		text: undefined,
// 		code2: "int countConsonants(string s) {  // Implement the logic here }",
// 		choices: [
// 			"1. return 0;",
// 			"2. return s.size();",
// 			"3. int count = 0; for (char c : s) { if (isalpha(c) && !(c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u')) { count++; } } return count;",
// 			"4. return s.length();",
// 		],
// 		answer: "3. int count = 0; for (char c : s) { if (isalpha(c) && !(c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u')) { count++; } } return count;",
// 		solution:
// 			"int countConsonants(string s) { int count = 0; for (char c : s) { if (isalpha(c) && !(c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u')) { count++; } } return count; }",
// 	},
// 	{
// 		id: 194,
// 		title: "# Q194. Given an array of integers, return the number of elements greater than a given value.",
// 		text: undefined,
// 		code2: "int countGreaterThan(vector<int>& nums, int val) {  // Implement the logic here }",
// 		choices: [
// 			"1. return 0;",
// 			"2. return nums.size();",
// 			"3. int count = 0; for (int num : nums) { if (num > val) { count++; } } return count;",
// 			"4. return nums.length();",
// 		],
// 		answer: "3. int count = 0; for (int num : nums) { if (num > val) { count++; } } return count;",
// 		solution:
// 			"int countGreaterThan(vector<int>& nums, int val) { int count = 0; for (int num : nums) { if (num > val) { count++; } } return count; }",
// 	},
// 	{
// 		id: 195,
// 		title: "# Q195. Given a string, return the number of uppercase letters.",
// 		text: undefined,
// 		code2: "int countUppercase(string s) {  // Implement the logic here }",
// 		choices: [
// 			"1. return 0;",
// 			"2. return s.size();",
// 			"3. int count = 0; for (char c : s) { if (isupper(c)) { count++; } } return count;",
// 			"4. return s.length();",
// 		],
// 		answer: "3. int count = 0; for (char c : s) { if (isupper(c)) { count++; } } return count;",
// 		solution:
// 			"int countUppercase(string s) { int count = 0; for (char c : s) { if (isupper(c)) { count++; } } return count; }",
// 	},
// 	{
// 		id: 196,
// 		title: "# Q196. Given an array of integers, return the number of elements less than a given value.",
// 		text: undefined,
// 		code2: "int countLessThan(vector<int>& nums, int val) {  // Implement the logic here }",
// 		choices: [
// 			"1. return 0;",
// 			"2. return nums.size();",
// 			"3. int count = 0; for (int num : nums) { if (num < val) { count++; } } return count;",
// 			"4. return nums.length();",
// 		],
// 		answer: "3. int count = 0; for (int num : nums) { if (num < val) { count++; } } return count;",
// 		solution:
// 			"int countLessThan(vector<int>& nums, int val) { int count = 0; for (int num : nums) { if (num < val) { count++; } } return count; }",
// 	},
// 	{
// 		id: 197,
// 		title: "# Q197. Given a string, return the number of digits.",
// 		text: undefined,
// 		code2: "int countDigits(string s) {  // Implement the logic here }",
// 		choices: [
// 			"1. return 0;",
// 			"2. return s.size();",
// 			"3. int count = 0; for (char c : s) { if (isdigit(c)) { count++; } } return count;",
// 			"4. return s.length();",
// 		],
// 		answer: "3. int count = 0; for (char c : s) { if (isdigit(c)) { count++; } } return count;",
// 		solution:
// 			"int countDigits(string s) { int count = 0; for (char c : s) { if (isdigit(c)) { count++; } } return count; }",
// 	},
// 	{
// 		id: 198,
// 		title: "# Q198. Given an array of integers, return the number of elements equal to a given value.",
// 		text: undefined,
// 		code2: "int countEqualTo(vector<int>& nums, int val) {  // Implement the logic here }",
// 		choices: [
// 			"1. return 0;",
// 			"2. return nums.size();",
// 			"3. int count = 0; for (int num : nums) { if (num == val) { count++; } } return count;",
// 			"4. return nums.length();",
// 		],
// 		answer: "3. int count = 0; for (int num : nums) { if (num == val) { count++; } } return count;",
// 		solution:
// 			"int countEqualTo(vector<int>& nums, int val) { int count = 0; for (int num : nums) { if (num == val) { count++; } } return count; }",
// 	},
// 	{
// 		id: 199,
// 		title: "# Q199. Given a string, return the number of lowercase letters.",
// 		text: undefined,
// 		code2: "int countLowercase(string s) {  // Implement the logic here }",
// 		choices: [
// 			"1. return 0;",
// 			"2. return s.size();",
// 			"3. int count = 0; for (char c : s) { if (islower(c)) { count++; } } return count;",
// 			"4. return s.length();",
// 		],
// 		answer: "3. int count = 0; for (char c : s) { if (islower(c)) { count++; } } return count;",
// 		solution:
// 			"int countLowercase(string s) { int count = 0; for (char c : s) { if (islower(c)) { count++; } } return count; }",
// 	},
	
// ]
// let cppq1 = cpp[Math.floor(Math.random())* cpp.length+9];
// // console.log(cppq1);

// chrome.runtime.onMessage.addListener((request, sender, sendResponse) => {
// 	if (request.message === "getRandomQuestion") {
// 		const randomQuestion = cpp[Math.floor(Math.random()) * cpp.length ];

// 		sendResponse([randomQuestion]);
// 		console.log("Sending response for question:", randomQuestion);
// 	}
// });

// chrome.runtime.onMessage.addListener((request, sender, sendResponse) => {
// 	if (request.message === "getRandomQuestion") {
// 		console.log("Received getRandomQuestion message");

// 		let millisecs = Date.now();
// 		console.log(millisecs);

// 		if (millisecs % 6 == 0 || millisecs % 7 == 0) {
// 			const randomQuestion = cpp[Math.floor(Math.random() * cpp.length)];

// 			console.log("Sending response for question:", randomQuestion);
// 			sendResponse([randomQuestion]);
// 		}

// 		if (millisecs % 8 == 0 || millisecs % 9 == 0) {
// 			const randomQuestion = dsa3[Math.floor(Math.random() * cpp.length)];

// 			console.log("Sending response for question:", randomQuestion);
// 			sendResponse([randomQuestion]);
// 		}

// 		if (millisecs % 2 == 1 || millisecs % 3 == 3 || millisecs % 3 == 0) {
// 			const randomQuestion = ds[Math.floor(Math.random() * cpp.length)];

// 			console.log("Sending response for question:", randomQuestion);
// 			sendResponse([randomQuestion]);
// 		} else {
// 			const randomQuestion = cpp[Math.floor(Math.random() * cpp.length)];

// 			console.log("Sending response for question:", randomQuestion);
// 			sendResponse([randomQuestion]);
// 		}
// 	}
// });

chrome.runtime.onMessage.addListener((request,sender,sendResponse)=>{
    if(request.message==="getRandomQuestion"){
        console.log("Received getRandomQuestion message");
        const randomQuestion = cpp[Math.floor(Math.random() * cpp.length)];
        console.log("Sending response for question:", randomQuestion);
        sendResponse([randomQuestion]);
    }
});
chrome.runtime.onMessage.addListener((request, sender, sendResponse) => {
    if (request.type === "change_quiz") {
        chrome.tabs.query({ active: true, currentWindow: true }, (tabs) => {
            chrome.tabs.sendMessage(tabs[0].id, request, (response) => {
                sendResponse(response);
            });
        });
        return true; // Keep the message channel open for sendResponse
    }
});